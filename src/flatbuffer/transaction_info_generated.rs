// automatically generated by the FlatBuffers compiler, do not modify

#[allow(unused_imports)]
use std::cmp::Ordering;
#[allow(unused_imports)]
use std::mem;

extern crate flatbuffers;
#[allow(unused_imports)]
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod transaction_info {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SANITIZED_MESSAGE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SANITIZED_MESSAGE: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SANITIZED_MESSAGE: [SanitizedMessage; 3] = [
        SanitizedMessage::NONE,
        SanitizedMessage::Legacy,
        SanitizedMessage::V0,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SanitizedMessage(pub u8);
    #[allow(non_upper_case_globals)]
    impl SanitizedMessage {
        pub const NONE: Self = Self(0);
        pub const Legacy: Self = Self(1);
        pub const V0: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Legacy, Self::V0];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Legacy => Some("Legacy"),
                Self::V0 => Some("V0"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for SanitizedMessage {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SanitizedMessage {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for SanitizedMessage {
        type Output = SanitizedMessage;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for SanitizedMessage {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SanitizedMessage {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SanitizedMessage {}
    pub struct SanitizedMessageUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_REWARD_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_REWARD_TYPE: u8 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_REWARD_TYPE: [RewardType; 5] = [
        RewardType::None,
        RewardType::Fee,
        RewardType::Rent,
        RewardType::Staking,
        RewardType::Voting,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct RewardType(pub u8);
    #[allow(non_upper_case_globals)]
    impl RewardType {
        pub const None: Self = Self(0);
        pub const Fee: Self = Self(1);
        pub const Rent: Self = Self(2);
        pub const Staking: Self = Self(3);
        pub const Voting: Self = Self(4);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::None,
            Self::Fee,
            Self::Rent,
            Self::Staking,
            Self::Voting,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::None => Some("None"),
                Self::Fee => Some("Fee"),
                Self::Rent => Some("Rent"),
                Self::Staking => Some("Staking"),
                Self::Voting => Some("Voting"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for RewardType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for RewardType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for RewardType {
        type Output = RewardType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for RewardType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for RewardType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for RewardType {}
    pub enum TransactionInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionInfo<'a> {
        type Inner = TransactionInfo<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TransactionInfo<'a> {
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
        pub const VT_IS_VOTE: flatbuffers::VOffsetT = 6;
        pub const VT_SLOT: flatbuffers::VOffsetT = 8;
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 10;
        pub const VT_TRANSACTION_META: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionInfo<'bldr>> {
            let mut builder = TransactionInfoBuilder::new(_fbb);
            builder.add_slot(args.slot);
            if let Some(x) = args.transaction_meta {
                builder.add_transaction_meta(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            builder.add_is_vote(args.is_vote);
            builder.finish()
        }

        #[inline]
        pub fn signature(&self) -> Option<Signature<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Signature>>(TransactionInfo::VT_SIGNATURE, None)
        }
        #[inline]
        pub fn is_vote(&self) -> bool {
            self._tab
                .get::<bool>(TransactionInfo::VT_IS_VOTE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn slot(&self) -> u64 {
            self._tab
                .get::<u64>(TransactionInfo::VT_SLOT, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn transaction(&self) -> Option<SanitizedTransaction<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SanitizedTransaction>>(
                    TransactionInfo::VT_TRANSACTION,
                    None,
                )
        }
        #[inline]
        pub fn transaction_meta(&self) -> Option<TransactionStatusMeta<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<TransactionStatusMeta>>(
                    TransactionInfo::VT_TRANSACTION_META,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for TransactionInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Signature>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<bool>("is_vote", Self::VT_IS_VOTE, false)?
                .visit_field::<u64>("slot", Self::VT_SLOT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<SanitizedTransaction>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<TransactionStatusMeta>>(
                    "transaction_meta",
                    Self::VT_TRANSACTION_META,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionInfoArgs<'a> {
        pub signature: Option<flatbuffers::WIPOffset<Signature<'a>>>,
        pub is_vote: bool,
        pub slot: u64,
        pub transaction: Option<flatbuffers::WIPOffset<SanitizedTransaction<'a>>>,
        pub transaction_meta: Option<flatbuffers::WIPOffset<TransactionStatusMeta<'a>>>,
    }
    impl<'a> Default for TransactionInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionInfoArgs {
                signature: None,
                is_vote: false,
                slot: 0,
                transaction: None,
                transaction_meta: None,
            }
        }
    }

    pub struct TransactionInfoBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionInfoBuilder<'a, 'b> {
        #[inline]
        pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<Signature<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Signature>>(
                    TransactionInfo::VT_SIGNATURE,
                    signature,
                );
        }
        #[inline]
        pub fn add_is_vote(&mut self, is_vote: bool) {
            self.fbb_
                .push_slot::<bool>(TransactionInfo::VT_IS_VOTE, is_vote, false);
        }
        #[inline]
        pub fn add_slot(&mut self, slot: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionInfo::VT_SLOT, slot, 0);
        }
        #[inline]
        pub fn add_transaction(
            &mut self,
            transaction: flatbuffers::WIPOffset<SanitizedTransaction<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SanitizedTransaction>>(
                    TransactionInfo::VT_TRANSACTION,
                    transaction,
                );
        }
        #[inline]
        pub fn add_transaction_meta(
            &mut self,
            transaction_meta: flatbuffers::WIPOffset<TransactionStatusMeta<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<TransactionStatusMeta>>(
                    TransactionInfo::VT_TRANSACTION_META,
                    transaction_meta,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionInfoBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionInfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TransactionInfo<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TransactionInfo");
            ds.field("signature", &self.signature());
            ds.field("is_vote", &self.is_vote());
            ds.field("slot", &self.slot());
            ds.field("transaction", &self.transaction());
            ds.field("transaction_meta", &self.transaction_meta());
            ds.finish()
        }
    }
    pub enum SanitizedTransactionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SanitizedTransaction<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SanitizedTransaction<'a> {
        type Inner = SanitizedTransaction<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> SanitizedTransaction<'a> {
        pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;
        pub const VT_MESSAGE_HASH: flatbuffers::VOffsetT = 8;
        pub const VT_IS_SIMPLE_VOTE_TX: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURES: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SanitizedTransaction { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SanitizedTransactionArgs<'args>,
        ) -> flatbuffers::WIPOffset<SanitizedTransaction<'bldr>> {
            let mut builder = SanitizedTransactionBuilder::new(_fbb);
            if let Some(x) = args.signatures {
                builder.add_signatures(x);
            }
            if let Some(x) = args.message_hash {
                builder.add_message_hash(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.add_is_simple_vote_tx(args.is_simple_vote_tx);
            builder.add_message_type(args.message_type);
            builder.finish()
        }

        #[inline]
        pub fn message_type(&self) -> SanitizedMessage {
            self._tab
                .get::<SanitizedMessage>(
                    SanitizedTransaction::VT_MESSAGE_TYPE,
                    Some(SanitizedMessage::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SanitizedTransaction::VT_MESSAGE,
                    None,
                )
        }
        #[inline]
        pub fn message_hash(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    SanitizedTransaction::VT_MESSAGE_HASH,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn is_simple_vote_tx(&self) -> bool {
            self._tab
                .get::<bool>(SanitizedTransaction::VT_IS_SIMPLE_VOTE_TX, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn signatures(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature>>,
            >>(SanitizedTransaction::VT_SIGNATURES, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn message_as_legacy(&self) -> Option<LegacyMessage<'a>> {
            if self.message_type() == SanitizedMessage::Legacy {
                self.message().map(LegacyMessage::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn message_as_v0(&self) -> Option<LoadedMessageV0<'a>> {
            if self.message_type() == SanitizedMessage::V0 {
                self.message().map(LoadedMessageV0::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for SanitizedTransaction<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<SanitizedMessage, _>(
                    "message_type",
                    Self::VT_MESSAGE_TYPE,
                    "message",
                    Self::VT_MESSAGE,
                    false,
                    |key, v, pos| match key {
                        SanitizedMessage::Legacy => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<LegacyMessage>>(
                                "SanitizedMessage::Legacy",
                                pos,
                            ),
                        SanitizedMessage::V0 => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<LoadedMessageV0>>(
                                "SanitizedMessage::V0",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "message_hash",
                    Self::VT_MESSAGE_HASH,
                    false,
                )?
                .visit_field::<bool>("is_simple_vote_tx", Self::VT_IS_SIMPLE_VOTE_TX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Signature>>,
                >>("signatures", Self::VT_SIGNATURES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SanitizedTransactionArgs<'a> {
        pub message_type: SanitizedMessage,
        pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub message_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub is_simple_vote_tx: bool,
        pub signatures: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Signature<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SanitizedTransactionArgs<'a> {
        #[inline]
        fn default() -> Self {
            SanitizedTransactionArgs {
                message_type: SanitizedMessage::NONE,
                message: None,
                message_hash: None,
                is_simple_vote_tx: false,
                signatures: None,
            }
        }
    }

    pub struct SanitizedTransactionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SanitizedTransactionBuilder<'a, 'b> {
        #[inline]
        pub fn add_message_type(&mut self, message_type: SanitizedMessage) {
            self.fbb_.push_slot::<SanitizedMessage>(
                SanitizedTransaction::VT_MESSAGE_TYPE,
                message_type,
                SanitizedMessage::NONE,
            );
        }
        #[inline]
        pub fn add_message(
            &mut self,
            message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SanitizedTransaction::VT_MESSAGE,
                message,
            );
        }
        #[inline]
        pub fn add_message_hash(
            &mut self,
            message_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SanitizedTransaction::VT_MESSAGE_HASH,
                message_hash,
            );
        }
        #[inline]
        pub fn add_is_simple_vote_tx(&mut self, is_simple_vote_tx: bool) {
            self.fbb_.push_slot::<bool>(
                SanitizedTransaction::VT_IS_SIMPLE_VOTE_TX,
                is_simple_vote_tx,
                false,
            );
        }
        #[inline]
        pub fn add_signatures(
            &mut self,
            signatures: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Signature<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SanitizedTransaction::VT_SIGNATURES,
                signatures,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SanitizedTransactionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SanitizedTransactionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SanitizedTransaction<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for SanitizedTransaction<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("SanitizedTransaction");
            ds.field("message_type", &self.message_type());
            match self.message_type() {
                SanitizedMessage::Legacy => {
                    if let Some(x) = self.message_as_legacy() {
                        ds.field("message", &x)
                    } else {
                        ds.field(
                            "message",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                SanitizedMessage::V0 => {
                    if let Some(x) = self.message_as_v0() {
                        ds.field("message", &x)
                    } else {
                        ds.field(
                            "message",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("message", &x)
                }
            };
            ds.field("message_hash", &self.message_hash());
            ds.field("is_simple_vote_tx", &self.is_simple_vote_tx());
            ds.field("signatures", &self.signatures());
            ds.finish()
        }
    }
    pub enum LegacyMessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LegacyMessage<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LegacyMessage<'a> {
        type Inner = LegacyMessage<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> LegacyMessage<'a> {
        pub const VT_HEADER: flatbuffers::VOffsetT = 4;
        pub const VT_ACCOUNT_KEYS: flatbuffers::VOffsetT = 6;
        pub const VT_RECENT_BLOCKHASH: flatbuffers::VOffsetT = 8;
        pub const VT_INSTRUCTIONS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LegacyMessage { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LegacyMessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<LegacyMessage<'bldr>> {
            let mut builder = LegacyMessageBuilder::new(_fbb);
            if let Some(x) = args.instructions {
                builder.add_instructions(x);
            }
            if let Some(x) = args.recent_blockhash {
                builder.add_recent_blockhash(x);
            }
            if let Some(x) = args.account_keys {
                builder.add_account_keys(x);
            }
            if let Some(x) = args.header {
                builder.add_header(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn header(&self) -> Option<MessageHeader<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MessageHeader>>(LegacyMessage::VT_HEADER, None)
        }
        #[inline]
        pub fn account_keys(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
            >>(LegacyMessage::VT_ACCOUNT_KEYS, None)
        }
        #[inline]
        pub fn recent_blockhash(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    LegacyMessage::VT_RECENT_BLOCKHASH,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn instructions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
            >>(LegacyMessage::VT_INSTRUCTIONS, None)
        }
    }

    impl flatbuffers::Verifiable for LegacyMessage<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<MessageHeader>>(
                    "header",
                    Self::VT_HEADER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("account_keys", Self::VT_ACCOUNT_KEYS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "recent_blockhash",
                    Self::VT_RECENT_BLOCKHASH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
                >>("instructions", Self::VT_INSTRUCTIONS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LegacyMessageArgs<'a> {
        pub header: Option<flatbuffers::WIPOffset<MessageHeader<'a>>>,
        pub account_keys: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
        pub recent_blockhash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub instructions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>,
            >,
        >,
    }
    impl<'a> Default for LegacyMessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            LegacyMessageArgs {
                header: None,
                account_keys: None,
                recent_blockhash: None,
                instructions: None,
            }
        }
    }

    pub struct LegacyMessageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LegacyMessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_header(&mut self, header: flatbuffers::WIPOffset<MessageHeader<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MessageHeader>>(
                    LegacyMessage::VT_HEADER,
                    header,
                );
        }
        #[inline]
        pub fn add_account_keys(
            &mut self,
            account_keys: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LegacyMessage::VT_ACCOUNT_KEYS,
                account_keys,
            );
        }
        #[inline]
        pub fn add_recent_blockhash(
            &mut self,
            recent_blockhash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LegacyMessage::VT_RECENT_BLOCKHASH,
                recent_blockhash,
            );
        }
        #[inline]
        pub fn add_instructions(
            &mut self,
            instructions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CompiledInstruction<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LegacyMessage::VT_INSTRUCTIONS,
                instructions,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LegacyMessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LegacyMessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LegacyMessage<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for LegacyMessage<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("LegacyMessage");
            ds.field("header", &self.header());
            ds.field("account_keys", &self.account_keys());
            ds.field("recent_blockhash", &self.recent_blockhash());
            ds.field("instructions", &self.instructions());
            ds.finish()
        }
    }
    pub enum SignatureOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Signature<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Signature<'a> {
        type Inner = Signature<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Signature<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Signature { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SignatureArgs<'args>,
        ) -> flatbuffers::WIPOffset<Signature<'bldr>> {
            let mut builder = SignatureBuilder::new(_fbb);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Signature::VT_KEY,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Signature<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "key",
                    Self::VT_KEY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SignatureArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SignatureArgs<'a> {
        #[inline]
        fn default() -> Self {
            SignatureArgs { key: None }
        }
    }

    pub struct SignatureBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SignatureBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Signature::VT_KEY, key);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignatureBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SignatureBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Signature<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Signature<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Signature");
            ds.field("key", &self.key());
            ds.finish()
        }
    }
    pub enum PubkeyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Pubkey<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Pubkey<'a> {
        type Inner = Pubkey<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Pubkey<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Pubkey { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PubkeyArgs<'args>,
        ) -> flatbuffers::WIPOffset<Pubkey<'bldr>> {
            let mut builder = PubkeyBuilder::new(_fbb);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Pubkey::VT_KEY,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Pubkey<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "key",
                    Self::VT_KEY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PubkeyArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PubkeyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PubkeyArgs { key: None }
        }
    }

    pub struct PubkeyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PubkeyBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Pubkey::VT_KEY, key);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PubkeyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PubkeyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Pubkey<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Pubkey<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Pubkey");
            ds.field("key", &self.key());
            ds.finish()
        }
    }
    pub enum MessageHeaderOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageHeader<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageHeader<'a> {
        type Inner = MessageHeader<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MessageHeader<'a> {
        pub const VT_NUM_REQUIRED_SIGNATURES: flatbuffers::VOffsetT = 4;
        pub const VT_NUM_READONLY_SIGNED_ACCOUNTS: flatbuffers::VOffsetT = 6;
        pub const VT_NUM_READONLY_UNSIGNED_ACCOUNTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageHeader { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageHeaderArgs,
        ) -> flatbuffers::WIPOffset<MessageHeader<'bldr>> {
            let mut builder = MessageHeaderBuilder::new(_fbb);
            builder.add_num_readonly_unsigned_accounts(args.num_readonly_unsigned_accounts);
            builder.add_num_readonly_signed_accounts(args.num_readonly_signed_accounts);
            builder.add_num_required_signatures(args.num_required_signatures);
            builder.finish()
        }

        #[inline]
        pub fn num_required_signatures(&self) -> u8 {
            self._tab
                .get::<u8>(MessageHeader::VT_NUM_REQUIRED_SIGNATURES, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn num_readonly_signed_accounts(&self) -> u8 {
            self._tab
                .get::<u8>(MessageHeader::VT_NUM_READONLY_SIGNED_ACCOUNTS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn num_readonly_unsigned_accounts(&self) -> u8 {
            self._tab
                .get::<u8>(MessageHeader::VT_NUM_READONLY_UNSIGNED_ACCOUNTS, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for MessageHeader<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>(
                    "num_required_signatures",
                    Self::VT_NUM_REQUIRED_SIGNATURES,
                    false,
                )?
                .visit_field::<u8>(
                    "num_readonly_signed_accounts",
                    Self::VT_NUM_READONLY_SIGNED_ACCOUNTS,
                    false,
                )?
                .visit_field::<u8>(
                    "num_readonly_unsigned_accounts",
                    Self::VT_NUM_READONLY_UNSIGNED_ACCOUNTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageHeaderArgs {
        pub num_required_signatures: u8,
        pub num_readonly_signed_accounts: u8,
        pub num_readonly_unsigned_accounts: u8,
    }
    impl<'a> Default for MessageHeaderArgs {
        #[inline]
        fn default() -> Self {
            MessageHeaderArgs {
                num_required_signatures: 0,
                num_readonly_signed_accounts: 0,
                num_readonly_unsigned_accounts: 0,
            }
        }
    }

    pub struct MessageHeaderBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageHeaderBuilder<'a, 'b> {
        #[inline]
        pub fn add_num_required_signatures(&mut self, num_required_signatures: u8) {
            self.fbb_.push_slot::<u8>(
                MessageHeader::VT_NUM_REQUIRED_SIGNATURES,
                num_required_signatures,
                0,
            );
        }
        #[inline]
        pub fn add_num_readonly_signed_accounts(&mut self, num_readonly_signed_accounts: u8) {
            self.fbb_.push_slot::<u8>(
                MessageHeader::VT_NUM_READONLY_SIGNED_ACCOUNTS,
                num_readonly_signed_accounts,
                0,
            );
        }
        #[inline]
        pub fn add_num_readonly_unsigned_accounts(&mut self, num_readonly_unsigned_accounts: u8) {
            self.fbb_.push_slot::<u8>(
                MessageHeader::VT_NUM_READONLY_UNSIGNED_ACCOUNTS,
                num_readonly_unsigned_accounts,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MessageHeaderBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageHeaderBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageHeader<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MessageHeader<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MessageHeader");
            ds.field("num_required_signatures", &self.num_required_signatures());
            ds.field(
                "num_readonly_signed_accounts",
                &self.num_readonly_signed_accounts(),
            );
            ds.field(
                "num_readonly_unsigned_accounts",
                &self.num_readonly_unsigned_accounts(),
            );
            ds.finish()
        }
    }
    pub enum CompiledInstructionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CompiledInstruction<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CompiledInstruction<'a> {
        type Inner = CompiledInstruction<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> CompiledInstruction<'a> {
        pub const VT_PROGRAM_ID_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 6;
        pub const VT_DATA: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CompiledInstruction { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CompiledInstructionArgs<'args>,
        ) -> flatbuffers::WIPOffset<CompiledInstruction<'bldr>> {
            let mut builder = CompiledInstructionBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            if let Some(x) = args.accounts {
                builder.add_accounts(x);
            }
            builder.add_program_id_index(args.program_id_index);
            builder.finish()
        }

        #[inline]
        pub fn program_id_index(&self) -> u8 {
            self._tab
                .get::<u8>(CompiledInstruction::VT_PROGRAM_ID_INDEX, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn accounts(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    CompiledInstruction::VT_ACCOUNTS,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn data(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    CompiledInstruction::VT_DATA,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for CompiledInstruction<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("program_id_index", Self::VT_PROGRAM_ID_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "accounts",
                    Self::VT_ACCOUNTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CompiledInstructionArgs<'a> {
        pub program_id_index: u8,
        pub accounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CompiledInstructionArgs<'a> {
        #[inline]
        fn default() -> Self {
            CompiledInstructionArgs {
                program_id_index: 0,
                accounts: None,
                data: None,
            }
        }
    }

    pub struct CompiledInstructionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CompiledInstructionBuilder<'a, 'b> {
        #[inline]
        pub fn add_program_id_index(&mut self, program_id_index: u8) {
            self.fbb_.push_slot::<u8>(
                CompiledInstruction::VT_PROGRAM_ID_INDEX,
                program_id_index,
                0,
            );
        }
        #[inline]
        pub fn add_accounts(
            &mut self,
            accounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                CompiledInstruction::VT_ACCOUNTS,
                accounts,
            );
        }
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CompiledInstruction::VT_DATA, data);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CompiledInstructionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CompiledInstructionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CompiledInstruction<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for CompiledInstruction<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("CompiledInstruction");
            ds.field("program_id_index", &self.program_id_index());
            ds.field("accounts", &self.accounts());
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum LoadedMessageV0Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LoadedMessageV0<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LoadedMessageV0<'a> {
        type Inner = LoadedMessageV0<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> LoadedMessageV0<'a> {
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
        pub const VT_LOADED_ADDRESSES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LoadedMessageV0 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LoadedMessageV0Args<'args>,
        ) -> flatbuffers::WIPOffset<LoadedMessageV0<'bldr>> {
            let mut builder = LoadedMessageV0Builder::new(_fbb);
            if let Some(x) = args.loaded_addresses {
                builder.add_loaded_addresses(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn message(&self) -> Option<MessageV0<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MessageV0>>(LoadedMessageV0::VT_MESSAGE, None)
        }
        #[inline]
        pub fn loaded_addresses(&self) -> Option<LoadedAddresses<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<LoadedAddresses>>(
                    LoadedMessageV0::VT_LOADED_ADDRESSES,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for LoadedMessageV0<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<MessageV0>>(
                    "message",
                    Self::VT_MESSAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<LoadedAddresses>>(
                    "loaded_addresses",
                    Self::VT_LOADED_ADDRESSES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct LoadedMessageV0Args<'a> {
        pub message: Option<flatbuffers::WIPOffset<MessageV0<'a>>>,
        pub loaded_addresses: Option<flatbuffers::WIPOffset<LoadedAddresses<'a>>>,
    }
    impl<'a> Default for LoadedMessageV0Args<'a> {
        #[inline]
        fn default() -> Self {
            LoadedMessageV0Args {
                message: None,
                loaded_addresses: None,
            }
        }
    }

    pub struct LoadedMessageV0Builder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LoadedMessageV0Builder<'a, 'b> {
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<MessageV0<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MessageV0>>(
                    LoadedMessageV0::VT_MESSAGE,
                    message,
                );
        }
        #[inline]
        pub fn add_loaded_addresses(
            &mut self,
            loaded_addresses: flatbuffers::WIPOffset<LoadedAddresses<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<LoadedAddresses>>(
                    LoadedMessageV0::VT_LOADED_ADDRESSES,
                    loaded_addresses,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LoadedMessageV0Builder<'a, 'b> {
            let start = _fbb.start_table();
            LoadedMessageV0Builder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LoadedMessageV0<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for LoadedMessageV0<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("LoadedMessageV0");
            ds.field("message", &self.message());
            ds.field("loaded_addresses", &self.loaded_addresses());
            ds.finish()
        }
    }
    pub enum MessageV0Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageV0<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageV0<'a> {
        type Inner = MessageV0<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MessageV0<'a> {
        pub const VT_HEADER: flatbuffers::VOffsetT = 4;
        pub const VT_ACCOUNT_KEYS: flatbuffers::VOffsetT = 6;
        pub const VT_RECENT_BLOCKHASH: flatbuffers::VOffsetT = 8;
        pub const VT_INSTRUCTIONS: flatbuffers::VOffsetT = 10;
        pub const VT_ADDRESS_TABLE_LOOKUPS: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageV0 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageV0Args<'args>,
        ) -> flatbuffers::WIPOffset<MessageV0<'bldr>> {
            let mut builder = MessageV0Builder::new(_fbb);
            if let Some(x) = args.address_table_lookups {
                builder.add_address_table_lookups(x);
            }
            if let Some(x) = args.instructions {
                builder.add_instructions(x);
            }
            if let Some(x) = args.recent_blockhash {
                builder.add_recent_blockhash(x);
            }
            if let Some(x) = args.account_keys {
                builder.add_account_keys(x);
            }
            if let Some(x) = args.header {
                builder.add_header(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn header(&self) -> Option<MessageHeader<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MessageHeader>>(MessageV0::VT_HEADER, None)
        }
        #[inline]
        pub fn account_keys(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
            >>(MessageV0::VT_ACCOUNT_KEYS, None)
        }
        #[inline]
        pub fn recent_blockhash(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    MessageV0::VT_RECENT_BLOCKHASH,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn instructions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
            >>(MessageV0::VT_INSTRUCTIONS, None)
        }
        #[inline]
        pub fn address_table_lookups(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MessageAddressTableLookup<'a>>>,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MessageAddressTableLookup>>,
            >>(MessageV0::VT_ADDRESS_TABLE_LOOKUPS, None)
        }
    }

    impl flatbuffers::Verifiable for MessageV0<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<MessageHeader>>(
                    "header",
                    Self::VT_HEADER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("account_keys", Self::VT_ACCOUNT_KEYS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "recent_blockhash",
                    Self::VT_RECENT_BLOCKHASH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
                >>("instructions", Self::VT_INSTRUCTIONS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<
                        '_,
                        flatbuffers::ForwardsUOffset<MessageAddressTableLookup>,
                    >,
                >>(
                    "address_table_lookups",
                    Self::VT_ADDRESS_TABLE_LOOKUPS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageV0Args<'a> {
        pub header: Option<flatbuffers::WIPOffset<MessageHeader<'a>>>,
        pub account_keys: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
        pub recent_blockhash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub instructions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>,
            >,
        >,
        pub address_table_lookups: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<MessageAddressTableLookup<'a>>,
                >,
            >,
        >,
    }
    impl<'a> Default for MessageV0Args<'a> {
        #[inline]
        fn default() -> Self {
            MessageV0Args {
                header: None,
                account_keys: None,
                recent_blockhash: None,
                instructions: None,
                address_table_lookups: None,
            }
        }
    }

    pub struct MessageV0Builder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageV0Builder<'a, 'b> {
        #[inline]
        pub fn add_header(&mut self, header: flatbuffers::WIPOffset<MessageHeader<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MessageHeader>>(
                    MessageV0::VT_HEADER,
                    header,
                );
        }
        #[inline]
        pub fn add_account_keys(
            &mut self,
            account_keys: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageV0::VT_ACCOUNT_KEYS,
                account_keys,
            );
        }
        #[inline]
        pub fn add_recent_blockhash(
            &mut self,
            recent_blockhash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageV0::VT_RECENT_BLOCKHASH,
                recent_blockhash,
            );
        }
        #[inline]
        pub fn add_instructions(
            &mut self,
            instructions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CompiledInstruction<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageV0::VT_INSTRUCTIONS,
                instructions,
            );
        }
        #[inline]
        pub fn add_address_table_lookups(
            &mut self,
            address_table_lookups: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<MessageAddressTableLookup<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageV0::VT_ADDRESS_TABLE_LOOKUPS,
                address_table_lookups,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageV0Builder<'a, 'b> {
            let start = _fbb.start_table();
            MessageV0Builder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageV0<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MessageV0<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MessageV0");
            ds.field("header", &self.header());
            ds.field("account_keys", &self.account_keys());
            ds.field("recent_blockhash", &self.recent_blockhash());
            ds.field("instructions", &self.instructions());
            ds.field("address_table_lookups", &self.address_table_lookups());
            ds.finish()
        }
    }
    pub enum MessageAddressTableLookupOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageAddressTableLookup<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageAddressTableLookup<'a> {
        type Inner = MessageAddressTableLookup<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MessageAddressTableLookup<'a> {
        pub const VT_ACCOUNT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_WRITABLE_INDEXES: flatbuffers::VOffsetT = 6;
        pub const VT_READONLY_INDEXES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageAddressTableLookup { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageAddressTableLookupArgs<'args>,
        ) -> flatbuffers::WIPOffset<MessageAddressTableLookup<'bldr>> {
            let mut builder = MessageAddressTableLookupBuilder::new(_fbb);
            if let Some(x) = args.readonly_indexes {
                builder.add_readonly_indexes(x);
            }
            if let Some(x) = args.writable_indexes {
                builder.add_writable_indexes(x);
            }
            if let Some(x) = args.account_key {
                builder.add_account_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn account_key(&self) -> Option<Pubkey<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<Pubkey>>(
                MessageAddressTableLookup::VT_ACCOUNT_KEY,
                None,
            )
        }
        #[inline]
        pub fn writable_indexes(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    MessageAddressTableLookup::VT_WRITABLE_INDEXES,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn readonly_indexes(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    MessageAddressTableLookup::VT_READONLY_INDEXES,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for MessageAddressTableLookup<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Pubkey>>(
                    "account_key",
                    Self::VT_ACCOUNT_KEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "writable_indexes",
                    Self::VT_WRITABLE_INDEXES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "readonly_indexes",
                    Self::VT_READONLY_INDEXES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageAddressTableLookupArgs<'a> {
        pub account_key: Option<flatbuffers::WIPOffset<Pubkey<'a>>>,
        pub writable_indexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub readonly_indexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MessageAddressTableLookupArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageAddressTableLookupArgs {
                account_key: None,
                writable_indexes: None,
                readonly_indexes: None,
            }
        }
    }

    pub struct MessageAddressTableLookupBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageAddressTableLookupBuilder<'a, 'b> {
        #[inline]
        pub fn add_account_key(&mut self, account_key: flatbuffers::WIPOffset<Pubkey<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Pubkey>>(
                    MessageAddressTableLookup::VT_ACCOUNT_KEY,
                    account_key,
                );
        }
        #[inline]
        pub fn add_writable_indexes(
            &mut self,
            writable_indexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageAddressTableLookup::VT_WRITABLE_INDEXES,
                writable_indexes,
            );
        }
        #[inline]
        pub fn add_readonly_indexes(
            &mut self,
            readonly_indexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageAddressTableLookup::VT_READONLY_INDEXES,
                readonly_indexes,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MessageAddressTableLookupBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageAddressTableLookupBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageAddressTableLookup<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MessageAddressTableLookup<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MessageAddressTableLookup");
            ds.field("account_key", &self.account_key());
            ds.field("writable_indexes", &self.writable_indexes());
            ds.field("readonly_indexes", &self.readonly_indexes());
            ds.finish()
        }
    }
    pub enum LoadedAddressesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LoadedAddresses<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LoadedAddresses<'a> {
        type Inner = LoadedAddresses<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> LoadedAddresses<'a> {
        pub const VT_WRITABLE: flatbuffers::VOffsetT = 4;
        pub const VT_READONLY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LoadedAddresses { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LoadedAddressesArgs<'args>,
        ) -> flatbuffers::WIPOffset<LoadedAddresses<'bldr>> {
            let mut builder = LoadedAddressesBuilder::new(_fbb);
            if let Some(x) = args.readonly {
                builder.add_readonly(x);
            }
            if let Some(x) = args.writable {
                builder.add_writable(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn writable(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
            >>(LoadedAddresses::VT_WRITABLE, None)
        }
        #[inline]
        pub fn readonly(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
            >>(LoadedAddresses::VT_READONLY, None)
        }
    }

    impl flatbuffers::Verifiable for LoadedAddresses<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("writable", Self::VT_WRITABLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("readonly", Self::VT_READONLY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LoadedAddressesArgs<'a> {
        pub writable: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
        pub readonly: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
    }
    impl<'a> Default for LoadedAddressesArgs<'a> {
        #[inline]
        fn default() -> Self {
            LoadedAddressesArgs {
                writable: None,
                readonly: None,
            }
        }
    }

    pub struct LoadedAddressesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LoadedAddressesBuilder<'a, 'b> {
        #[inline]
        pub fn add_writable(
            &mut self,
            writable: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LoadedAddresses::VT_WRITABLE,
                writable,
            );
        }
        #[inline]
        pub fn add_readonly(
            &mut self,
            readonly: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LoadedAddresses::VT_READONLY,
                readonly,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LoadedAddressesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LoadedAddressesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LoadedAddresses<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for LoadedAddresses<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("LoadedAddresses");
            ds.field("writable", &self.writable());
            ds.field("readonly", &self.readonly());
            ds.finish()
        }
    }
    pub enum TransactionStatusMetaOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionStatusMeta<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionStatusMeta<'a> {
        type Inner = TransactionStatusMeta<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TransactionStatusMeta<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_FEE: flatbuffers::VOffsetT = 6;
        pub const VT_PRE_BALANCES: flatbuffers::VOffsetT = 8;
        pub const VT_POST_BALANCES: flatbuffers::VOffsetT = 10;
        pub const VT_INNER_INSTRUCTIONS: flatbuffers::VOffsetT = 12;
        pub const VT_LOG_MESSAGES: flatbuffers::VOffsetT = 14;
        pub const VT_PRE_TOKEN_BALANCES: flatbuffers::VOffsetT = 16;
        pub const VT_POST_TOKEN_BALANCES: flatbuffers::VOffsetT = 18;
        pub const VT_REWARDS: flatbuffers::VOffsetT = 20;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionStatusMeta { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionStatusMetaArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionStatusMeta<'bldr>> {
            let mut builder = TransactionStatusMetaBuilder::new(_fbb);
            builder.add_fee(args.fee);
            if let Some(x) = args.rewards {
                builder.add_rewards(x);
            }
            if let Some(x) = args.post_token_balances {
                builder.add_post_token_balances(x);
            }
            if let Some(x) = args.pre_token_balances {
                builder.add_pre_token_balances(x);
            }
            if let Some(x) = args.log_messages {
                builder.add_log_messages(x);
            }
            if let Some(x) = args.inner_instructions {
                builder.add_inner_instructions(x);
            }
            if let Some(x) = args.post_balances {
                builder.add_post_balances(x);
            }
            if let Some(x) = args.pre_balances {
                builder.add_pre_balances(x);
            }
            builder.add_status(args.status);
            builder.finish()
        }

        #[inline]
        pub fn status(&self) -> bool {
            self._tab
                .get::<bool>(TransactionStatusMeta::VT_STATUS, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn fee(&self) -> u64 {
            self._tab
                .get::<u64>(TransactionStatusMeta::VT_FEE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn pre_balances(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                    TransactionStatusMeta::VT_PRE_BALANCES,
                    None,
                )
        }
        #[inline]
        pub fn post_balances(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                    TransactionStatusMeta::VT_POST_BALANCES,
                    None,
                )
        }
        #[inline]
        pub fn inner_instructions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InnerInstructions<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InnerInstructions>>,
            >>(TransactionStatusMeta::VT_INNER_INSTRUCTIONS, None)
        }
        #[inline]
        pub fn log_messages(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(TransactionStatusMeta::VT_LOG_MESSAGES, None)
        }
        #[inline]
        pub fn pre_token_balances(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
            >>(TransactionStatusMeta::VT_PRE_TOKEN_BALANCES, None)
        }
        #[inline]
        pub fn post_token_balances(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
            >>(TransactionStatusMeta::VT_POST_TOKEN_BALANCES, None)
        }
        #[inline]
        pub fn rewards(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Reward<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Reward>>,
            >>(TransactionStatusMeta::VT_REWARDS, None)
        }
    }

    impl flatbuffers::Verifiable for TransactionStatusMeta<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("status", Self::VT_STATUS, false)?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                    "pre_balances",
                    Self::VT_PRE_BALANCES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                    "post_balances",
                    Self::VT_POST_BALANCES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InnerInstructions>>,
                >>("inner_instructions", Self::VT_INNER_INSTRUCTIONS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("log_messages", Self::VT_LOG_MESSAGES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
                >>("pre_token_balances", Self::VT_PRE_TOKEN_BALANCES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
                >>("post_token_balances", Self::VT_POST_TOKEN_BALANCES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Reward>>,
                >>("rewards", Self::VT_REWARDS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionStatusMetaArgs<'a> {
        pub status: bool,
        pub fee: u64,
        pub pre_balances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
        pub post_balances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
        pub inner_instructions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InnerInstructions<'a>>>,
            >,
        >,
        pub log_messages: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub pre_token_balances: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
            >,
        >,
        pub post_token_balances: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
            >,
        >,
        pub rewards: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Reward<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TransactionStatusMetaArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionStatusMetaArgs {
                status: false,
                fee: 0,
                pre_balances: None,
                post_balances: None,
                inner_instructions: None,
                log_messages: None,
                pre_token_balances: None,
                post_token_balances: None,
                rewards: None,
            }
        }
    }

    pub struct TransactionStatusMetaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionStatusMetaBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: bool) {
            self.fbb_
                .push_slot::<bool>(TransactionStatusMeta::VT_STATUS, status, false);
        }
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionStatusMeta::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn add_pre_balances(
            &mut self,
            pre_balances: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_PRE_BALANCES,
                pre_balances,
            );
        }
        #[inline]
        pub fn add_post_balances(
            &mut self,
            post_balances: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_POST_BALANCES,
                post_balances,
            );
        }
        #[inline]
        pub fn add_inner_instructions(
            &mut self,
            inner_instructions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InnerInstructions<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_INNER_INSTRUCTIONS,
                inner_instructions,
            );
        }
        #[inline]
        pub fn add_log_messages(
            &mut self,
            log_messages: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_LOG_MESSAGES,
                log_messages,
            );
        }
        #[inline]
        pub fn add_pre_token_balances(
            &mut self,
            pre_token_balances: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_PRE_TOKEN_BALANCES,
                pre_token_balances,
            );
        }
        #[inline]
        pub fn add_post_token_balances(
            &mut self,
            post_token_balances: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_POST_TOKEN_BALANCES,
                post_token_balances,
            );
        }
        #[inline]
        pub fn add_rewards(
            &mut self,
            rewards: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Reward<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_REWARDS,
                rewards,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionStatusMetaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionStatusMetaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionStatusMeta<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TransactionStatusMeta<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TransactionStatusMeta");
            ds.field("status", &self.status());
            ds.field("fee", &self.fee());
            ds.field("pre_balances", &self.pre_balances());
            ds.field("post_balances", &self.post_balances());
            ds.field("inner_instructions", &self.inner_instructions());
            ds.field("log_messages", &self.log_messages());
            ds.field("pre_token_balances", &self.pre_token_balances());
            ds.field("post_token_balances", &self.post_token_balances());
            ds.field("rewards", &self.rewards());
            ds.finish()
        }
    }
    pub enum InnerInstructionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InnerInstructions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InnerInstructions<'a> {
        type Inner = InnerInstructions<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> InnerInstructions<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_INSTRUCTIONS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InnerInstructions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InnerInstructionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<InnerInstructions<'bldr>> {
            let mut builder = InnerInstructionsBuilder::new(_fbb);
            if let Some(x) = args.instructions {
                builder.add_instructions(x);
            }
            builder.add_index(args.index);
            builder.finish()
        }

        #[inline]
        pub fn index(&self) -> u8 {
            self._tab
                .get::<u8>(InnerInstructions::VT_INDEX, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn instructions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
            >>(InnerInstructions::VT_INSTRUCTIONS, None)
        }
    }

    impl flatbuffers::Verifiable for InnerInstructions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
                >>("instructions", Self::VT_INSTRUCTIONS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct InnerInstructionsArgs<'a> {
        pub index: u8,
        pub instructions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>,
            >,
        >,
    }
    impl<'a> Default for InnerInstructionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            InnerInstructionsArgs {
                index: 0,
                instructions: None,
            }
        }
    }

    pub struct InnerInstructionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InnerInstructionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_index(&mut self, index: u8) {
            self.fbb_
                .push_slot::<u8>(InnerInstructions::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_instructions(
            &mut self,
            instructions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CompiledInstruction<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                InnerInstructions::VT_INSTRUCTIONS,
                instructions,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> InnerInstructionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InnerInstructionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InnerInstructions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for InnerInstructions<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("InnerInstructions");
            ds.field("index", &self.index());
            ds.field("instructions", &self.instructions());
            ds.finish()
        }
    }
    pub enum TransactionTokenBalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionTokenBalance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionTokenBalance<'a> {
        type Inner = TransactionTokenBalance<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TransactionTokenBalance<'a> {
        pub const VT_ACCOUNT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_MINT: flatbuffers::VOffsetT = 6;
        pub const VT_UI_TOKEN_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_OWNER: flatbuffers::VOffsetT = 10;
        pub const VT_PROGRAM_ID: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionTokenBalance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionTokenBalanceArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionTokenBalance<'bldr>> {
            let mut builder = TransactionTokenBalanceBuilder::new(_fbb);
            if let Some(x) = args.program_id {
                builder.add_program_id(x);
            }
            if let Some(x) = args.owner {
                builder.add_owner(x);
            }
            if let Some(x) = args.ui_token_amount {
                builder.add_ui_token_amount(x);
            }
            if let Some(x) = args.mint {
                builder.add_mint(x);
            }
            builder.add_account_index(args.account_index);
            builder.finish()
        }

        #[inline]
        pub fn account_index(&self) -> u8 {
            self._tab
                .get::<u8>(TransactionTokenBalance::VT_ACCOUNT_INDEX, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn mint(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionTokenBalance::VT_MINT, None)
        }
        #[inline]
        pub fn ui_token_amount(&self) -> Option<UiTokenAmount<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<UiTokenAmount>>(
                    TransactionTokenBalance::VT_UI_TOKEN_AMOUNT,
                    None,
                )
        }
        #[inline]
        pub fn owner(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionTokenBalance::VT_OWNER, None)
        }
        #[inline]
        pub fn program_id(&self) -> Option<&'a str> {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransactionTokenBalance::VT_PROGRAM_ID,
                None,
            )
        }
    }

    impl flatbuffers::Verifiable for TransactionTokenBalance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("account_index", Self::VT_ACCOUNT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint", Self::VT_MINT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UiTokenAmount>>(
                    "ui_token_amount",
                    Self::VT_UI_TOKEN_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("owner", Self::VT_OWNER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "program_id",
                    Self::VT_PROGRAM_ID,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionTokenBalanceArgs<'a> {
        pub account_index: u8,
        pub mint: Option<flatbuffers::WIPOffset<&'a str>>,
        pub ui_token_amount: Option<flatbuffers::WIPOffset<UiTokenAmount<'a>>>,
        pub owner: Option<flatbuffers::WIPOffset<&'a str>>,
        pub program_id: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransactionTokenBalanceArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionTokenBalanceArgs {
                account_index: 0,
                mint: None,
                ui_token_amount: None,
                owner: None,
                program_id: None,
            }
        }
    }

    pub struct TransactionTokenBalanceBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionTokenBalanceBuilder<'a, 'b> {
        #[inline]
        pub fn add_account_index(&mut self, account_index: u8) {
            self.fbb_
                .push_slot::<u8>(TransactionTokenBalance::VT_ACCOUNT_INDEX, account_index, 0);
        }
        #[inline]
        pub fn add_mint(&mut self, mint: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionTokenBalance::VT_MINT,
                mint,
            );
        }
        #[inline]
        pub fn add_ui_token_amount(
            &mut self,
            ui_token_amount: flatbuffers::WIPOffset<UiTokenAmount<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<UiTokenAmount>>(
                    TransactionTokenBalance::VT_UI_TOKEN_AMOUNT,
                    ui_token_amount,
                );
        }
        #[inline]
        pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionTokenBalance::VT_OWNER,
                owner,
            );
        }
        #[inline]
        pub fn add_program_id(&mut self, program_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionTokenBalance::VT_PROGRAM_ID,
                program_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionTokenBalanceBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionTokenBalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionTokenBalance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TransactionTokenBalance<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TransactionTokenBalance");
            ds.field("account_index", &self.account_index());
            ds.field("mint", &self.mint());
            ds.field("ui_token_amount", &self.ui_token_amount());
            ds.field("owner", &self.owner());
            ds.field("program_id", &self.program_id());
            ds.finish()
        }
    }
    pub enum UiTokenAmountOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UiTokenAmount<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UiTokenAmount<'a> {
        type Inner = UiTokenAmount<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> UiTokenAmount<'a> {
        pub const VT_UI_AMOUNT: flatbuffers::VOffsetT = 4;
        pub const VT_DECIMALS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_UI_AMOUNT_STRING: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UiTokenAmount { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UiTokenAmountArgs<'args>,
        ) -> flatbuffers::WIPOffset<UiTokenAmount<'bldr>> {
            let mut builder = UiTokenAmountBuilder::new(_fbb);
            builder.add_ui_amount(args.ui_amount);
            if let Some(x) = args.ui_amount_string {
                builder.add_ui_amount_string(x);
            }
            if let Some(x) = args.amount {
                builder.add_amount(x);
            }
            builder.add_decimals(args.decimals);
            builder.finish()
        }

        #[inline]
        pub fn ui_amount(&self) -> f64 {
            self._tab
                .get::<f64>(UiTokenAmount::VT_UI_AMOUNT, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn decimals(&self) -> u8 {
            self._tab
                .get::<u8>(UiTokenAmount::VT_DECIMALS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn amount(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(UiTokenAmount::VT_AMOUNT, None)
        }
        #[inline]
        pub fn ui_amount_string(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(UiTokenAmount::VT_UI_AMOUNT_STRING, None)
        }
    }

    impl flatbuffers::Verifiable for UiTokenAmount<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f64>("ui_amount", Self::VT_UI_AMOUNT, false)?
                .visit_field::<u8>("decimals", Self::VT_DECIMALS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "amount",
                    Self::VT_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "ui_amount_string",
                    Self::VT_UI_AMOUNT_STRING,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UiTokenAmountArgs<'a> {
        pub ui_amount: f64,
        pub decimals: u8,
        pub amount: Option<flatbuffers::WIPOffset<&'a str>>,
        pub ui_amount_string: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UiTokenAmountArgs<'a> {
        #[inline]
        fn default() -> Self {
            UiTokenAmountArgs {
                ui_amount: 0.0,
                decimals: 0,
                amount: None,
                ui_amount_string: None,
            }
        }
    }

    pub struct UiTokenAmountBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UiTokenAmountBuilder<'a, 'b> {
        #[inline]
        pub fn add_ui_amount(&mut self, ui_amount: f64) {
            self.fbb_
                .push_slot::<f64>(UiTokenAmount::VT_UI_AMOUNT, ui_amount, 0.0);
        }
        #[inline]
        pub fn add_decimals(&mut self, decimals: u8) {
            self.fbb_
                .push_slot::<u8>(UiTokenAmount::VT_DECIMALS, decimals, 0);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UiTokenAmount::VT_AMOUNT, amount);
        }
        #[inline]
        pub fn add_ui_amount_string(&mut self, ui_amount_string: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UiTokenAmount::VT_UI_AMOUNT_STRING,
                ui_amount_string,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UiTokenAmountBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UiTokenAmountBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UiTokenAmount<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for UiTokenAmount<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("UiTokenAmount");
            ds.field("ui_amount", &self.ui_amount());
            ds.field("decimals", &self.decimals());
            ds.field("amount", &self.amount());
            ds.field("ui_amount_string", &self.ui_amount_string());
            ds.finish()
        }
    }
    pub enum RewardOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Reward<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Reward<'a> {
        type Inner = Reward<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Reward<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_LAMPORTS: flatbuffers::VOffsetT = 6;
        pub const VT_POST_BALANCE: flatbuffers::VOffsetT = 8;
        pub const VT_REWARD_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_COMMISSION: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Reward { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RewardArgs<'args>,
        ) -> flatbuffers::WIPOffset<Reward<'bldr>> {
            let mut builder = RewardBuilder::new(_fbb);
            builder.add_post_balance(args.post_balance);
            builder.add_lamports(args.lamports);
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.add_commission(args.commission);
            builder.add_reward_type(args.reward_type);
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Reward::VT_PUBKEY, None)
        }
        #[inline]
        pub fn lamports(&self) -> i64 {
            self._tab.get::<i64>(Reward::VT_LAMPORTS, Some(0)).unwrap()
        }
        #[inline]
        pub fn post_balance(&self) -> u64 {
            self._tab
                .get::<u64>(Reward::VT_POST_BALANCE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn reward_type(&self) -> RewardType {
            self._tab
                .get::<RewardType>(Reward::VT_REWARD_TYPE, Some(RewardType::None))
                .unwrap()
        }
        #[inline]
        pub fn commission(&self) -> u8 {
            self._tab.get::<u8>(Reward::VT_COMMISSION, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Reward<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<i64>("lamports", Self::VT_LAMPORTS, false)?
                .visit_field::<u64>("post_balance", Self::VT_POST_BALANCE, false)?
                .visit_field::<RewardType>("reward_type", Self::VT_REWARD_TYPE, false)?
                .visit_field::<u8>("commission", Self::VT_COMMISSION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RewardArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
        pub lamports: i64,
        pub post_balance: u64,
        pub reward_type: RewardType,
        pub commission: u8,
    }
    impl<'a> Default for RewardArgs<'a> {
        #[inline]
        fn default() -> Self {
            RewardArgs {
                pubkey: None,
                lamports: 0,
                post_balance: 0,
                reward_type: RewardType::None,
                commission: 0,
            }
        }
    }

    pub struct RewardBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RewardBuilder<'a, 'b> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Reward::VT_PUBKEY, pubkey);
        }
        #[inline]
        pub fn add_lamports(&mut self, lamports: i64) {
            self.fbb_.push_slot::<i64>(Reward::VT_LAMPORTS, lamports, 0);
        }
        #[inline]
        pub fn add_post_balance(&mut self, post_balance: u64) {
            self.fbb_
                .push_slot::<u64>(Reward::VT_POST_BALANCE, post_balance, 0);
        }
        #[inline]
        pub fn add_reward_type(&mut self, reward_type: RewardType) {
            self.fbb_.push_slot::<RewardType>(
                Reward::VT_REWARD_TYPE,
                reward_type,
                RewardType::None,
            );
        }
        #[inline]
        pub fn add_commission(&mut self, commission: u8) {
            self.fbb_
                .push_slot::<u8>(Reward::VT_COMMISSION, commission, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RewardBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RewardBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Reward<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Reward<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Reward");
            ds.field("pubkey", &self.pubkey());
            ds.field("lamports", &self.lamports());
            ds.field("post_balance", &self.post_balance());
            ds.field("reward_type", &self.reward_type());
            ds.field("commission", &self.commission());
            ds.finish()
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_transaction_info<'a>(buf: &'a [u8]) -> TransactionInfo<'a> {
        unsafe { flatbuffers::root_unchecked::<TransactionInfo<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_transaction_info<'a>(buf: &'a [u8]) -> TransactionInfo<'a> {
        unsafe { flatbuffers::size_prefixed_root_unchecked::<TransactionInfo<'a>>(buf) }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `TransactionInfo`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_info_unchecked`.
    pub fn root_as_transaction_info(
        buf: &[u8],
    ) -> Result<TransactionInfo, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<TransactionInfo>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `TransactionInfo` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_transaction_info_unchecked`.
    pub fn size_prefixed_root_as_transaction_info(
        buf: &[u8],
    ) -> Result<TransactionInfo, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<TransactionInfo>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `TransactionInfo` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_info_unchecked`.
    pub fn root_as_transaction_info_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<TransactionInfo<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<TransactionInfo<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `TransactionInfo` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_info_unchecked`.
    pub fn size_prefixed_root_as_transaction_info_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<TransactionInfo<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<TransactionInfo<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a TransactionInfo and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `TransactionInfo`.
    pub unsafe fn root_as_transaction_info_unchecked(buf: &[u8]) -> TransactionInfo {
        flatbuffers::root_unchecked::<TransactionInfo>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed TransactionInfo and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `TransactionInfo`.
    pub unsafe fn size_prefixed_root_as_transaction_info_unchecked(buf: &[u8]) -> TransactionInfo {
        flatbuffers::size_prefixed_root_unchecked::<TransactionInfo>(buf)
    }
    #[inline]
    pub fn finish_transaction_info_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<TransactionInfo<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_transaction_info_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<TransactionInfo<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod TransactionInfo

// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod transaction_info {

    use crate::flatbuffer::common_generated::common::*;
    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TRANSACTION_ERROR_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TRANSACTION_ERROR_TYPE: u8 = 31;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TRANSACTION_ERROR_TYPE: [TransactionErrorType; 32] = [
        TransactionErrorType::AccountInUse,
        TransactionErrorType::AccountLoadedTwice,
        TransactionErrorType::AccountNotFound,
        TransactionErrorType::ProgramAccountNotFound,
        TransactionErrorType::InsufficientFundsForFee,
        TransactionErrorType::InvalidAccountForFee,
        TransactionErrorType::AlreadyProcessed,
        TransactionErrorType::BlockhashNotFound,
        TransactionErrorType::InstructionError,
        TransactionErrorType::CallChainTooDeep,
        TransactionErrorType::MissingSignatureForFee,
        TransactionErrorType::InvalidAccountIndex,
        TransactionErrorType::SignatureFailure,
        TransactionErrorType::InvalidProgramForExecution,
        TransactionErrorType::SanitizeFailure,
        TransactionErrorType::ClusterMaintenance,
        TransactionErrorType::AccountBorrowOutstanding,
        TransactionErrorType::WouldExceedMaxBlockCostLimit,
        TransactionErrorType::UnsupportedVersion,
        TransactionErrorType::InvalidWritableAccount,
        TransactionErrorType::WouldExceedMaxAccountCostLimit,
        TransactionErrorType::WouldExceedAccountDataBlockLimit,
        TransactionErrorType::TooManyAccountLocks,
        TransactionErrorType::AddressLookupTableNotFound,
        TransactionErrorType::InvalidAddressLookupTableOwner,
        TransactionErrorType::InvalidAddressLookupTableData,
        TransactionErrorType::InvalidAddressLookupTableIndex,
        TransactionErrorType::InvalidRentPayingAccount,
        TransactionErrorType::WouldExceedMaxVoteCostLimit,
        TransactionErrorType::WouldExceedAccountDataTotalLimit,
        TransactionErrorType::DuplicateInstruction,
        TransactionErrorType::InsufficientFundsForRent,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TransactionErrorType(pub u8);
    #[allow(non_upper_case_globals)]
    impl TransactionErrorType {
        pub const AccountInUse: Self = Self(0);
        pub const AccountLoadedTwice: Self = Self(1);
        pub const AccountNotFound: Self = Self(2);
        pub const ProgramAccountNotFound: Self = Self(3);
        pub const InsufficientFundsForFee: Self = Self(4);
        pub const InvalidAccountForFee: Self = Self(5);
        pub const AlreadyProcessed: Self = Self(6);
        pub const BlockhashNotFound: Self = Self(7);
        pub const InstructionError: Self = Self(8);
        pub const CallChainTooDeep: Self = Self(9);
        pub const MissingSignatureForFee: Self = Self(10);
        pub const InvalidAccountIndex: Self = Self(11);
        pub const SignatureFailure: Self = Self(12);
        pub const InvalidProgramForExecution: Self = Self(13);
        pub const SanitizeFailure: Self = Self(14);
        pub const ClusterMaintenance: Self = Self(15);
        pub const AccountBorrowOutstanding: Self = Self(16);
        pub const WouldExceedMaxBlockCostLimit: Self = Self(17);
        pub const UnsupportedVersion: Self = Self(18);
        pub const InvalidWritableAccount: Self = Self(19);
        pub const WouldExceedMaxAccountCostLimit: Self = Self(20);
        pub const WouldExceedAccountDataBlockLimit: Self = Self(21);
        pub const TooManyAccountLocks: Self = Self(22);
        pub const AddressLookupTableNotFound: Self = Self(23);
        pub const InvalidAddressLookupTableOwner: Self = Self(24);
        pub const InvalidAddressLookupTableData: Self = Self(25);
        pub const InvalidAddressLookupTableIndex: Self = Self(26);
        pub const InvalidRentPayingAccount: Self = Self(27);
        pub const WouldExceedMaxVoteCostLimit: Self = Self(28);
        pub const WouldExceedAccountDataTotalLimit: Self = Self(29);
        pub const DuplicateInstruction: Self = Self(30);
        pub const InsufficientFundsForRent: Self = Self(31);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 31;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::AccountInUse,
            Self::AccountLoadedTwice,
            Self::AccountNotFound,
            Self::ProgramAccountNotFound,
            Self::InsufficientFundsForFee,
            Self::InvalidAccountForFee,
            Self::AlreadyProcessed,
            Self::BlockhashNotFound,
            Self::InstructionError,
            Self::CallChainTooDeep,
            Self::MissingSignatureForFee,
            Self::InvalidAccountIndex,
            Self::SignatureFailure,
            Self::InvalidProgramForExecution,
            Self::SanitizeFailure,
            Self::ClusterMaintenance,
            Self::AccountBorrowOutstanding,
            Self::WouldExceedMaxBlockCostLimit,
            Self::UnsupportedVersion,
            Self::InvalidWritableAccount,
            Self::WouldExceedMaxAccountCostLimit,
            Self::WouldExceedAccountDataBlockLimit,
            Self::TooManyAccountLocks,
            Self::AddressLookupTableNotFound,
            Self::InvalidAddressLookupTableOwner,
            Self::InvalidAddressLookupTableData,
            Self::InvalidAddressLookupTableIndex,
            Self::InvalidRentPayingAccount,
            Self::WouldExceedMaxVoteCostLimit,
            Self::WouldExceedAccountDataTotalLimit,
            Self::DuplicateInstruction,
            Self::InsufficientFundsForRent,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::AccountInUse => Some("AccountInUse"),
                Self::AccountLoadedTwice => Some("AccountLoadedTwice"),
                Self::AccountNotFound => Some("AccountNotFound"),
                Self::ProgramAccountNotFound => Some("ProgramAccountNotFound"),
                Self::InsufficientFundsForFee => Some("InsufficientFundsForFee"),
                Self::InvalidAccountForFee => Some("InvalidAccountForFee"),
                Self::AlreadyProcessed => Some("AlreadyProcessed"),
                Self::BlockhashNotFound => Some("BlockhashNotFound"),
                Self::InstructionError => Some("InstructionError"),
                Self::CallChainTooDeep => Some("CallChainTooDeep"),
                Self::MissingSignatureForFee => Some("MissingSignatureForFee"),
                Self::InvalidAccountIndex => Some("InvalidAccountIndex"),
                Self::SignatureFailure => Some("SignatureFailure"),
                Self::InvalidProgramForExecution => Some("InvalidProgramForExecution"),
                Self::SanitizeFailure => Some("SanitizeFailure"),
                Self::ClusterMaintenance => Some("ClusterMaintenance"),
                Self::AccountBorrowOutstanding => Some("AccountBorrowOutstanding"),
                Self::WouldExceedMaxBlockCostLimit => Some("WouldExceedMaxBlockCostLimit"),
                Self::UnsupportedVersion => Some("UnsupportedVersion"),
                Self::InvalidWritableAccount => Some("InvalidWritableAccount"),
                Self::WouldExceedMaxAccountCostLimit => Some("WouldExceedMaxAccountCostLimit"),
                Self::WouldExceedAccountDataBlockLimit => Some("WouldExceedAccountDataBlockLimit"),
                Self::TooManyAccountLocks => Some("TooManyAccountLocks"),
                Self::AddressLookupTableNotFound => Some("AddressLookupTableNotFound"),
                Self::InvalidAddressLookupTableOwner => Some("InvalidAddressLookupTableOwner"),
                Self::InvalidAddressLookupTableData => Some("InvalidAddressLookupTableData"),
                Self::InvalidAddressLookupTableIndex => Some("InvalidAddressLookupTableIndex"),
                Self::InvalidRentPayingAccount => Some("InvalidRentPayingAccount"),
                Self::WouldExceedMaxVoteCostLimit => Some("WouldExceedMaxVoteCostLimit"),
                Self::WouldExceedAccountDataTotalLimit => Some("WouldExceedAccountDataTotalLimit"),
                Self::DuplicateInstruction => Some("DuplicateInstruction"),
                Self::InsufficientFundsForRent => Some("InsufficientFundsForRent"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TransactionErrorType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TransactionErrorType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TransactionErrorType {
        type Output = TransactionErrorType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TransactionErrorType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TransactionErrorType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TransactionErrorType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_INSTRUCTION_ERROR_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_INSTRUCTION_ERROR_TYPE: u8 = 51;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_INSTRUCTION_ERROR_TYPE: [InstructionErrorType; 52] = [
        InstructionErrorType::GenericError,
        InstructionErrorType::InvalidArgument,
        InstructionErrorType::InvalidInstructionData,
        InstructionErrorType::InvalidAccountData,
        InstructionErrorType::AccountDataTooSmall,
        InstructionErrorType::InsufficientFunds,
        InstructionErrorType::IncorrectProgramId,
        InstructionErrorType::MissingRequiredSignature,
        InstructionErrorType::AccountAlreadyInitialized,
        InstructionErrorType::UninitializedAccount,
        InstructionErrorType::UnbalancedInstruction,
        InstructionErrorType::ModifiedProgramId,
        InstructionErrorType::ExternalAccountLamportSpend,
        InstructionErrorType::ExternalAccountDataModified,
        InstructionErrorType::ReadonlyLamportChange,
        InstructionErrorType::ReadonlyDataModified,
        InstructionErrorType::DuplicateAccountIndex,
        InstructionErrorType::ExecutableModified,
        InstructionErrorType::RentEpochModified,
        InstructionErrorType::NotEnoughAccountKeys,
        InstructionErrorType::AccountDataSizeChanged,
        InstructionErrorType::AccountNotExecutable,
        InstructionErrorType::AccountBorrowFailed,
        InstructionErrorType::AccountBorrowOutstanding,
        InstructionErrorType::DuplicateAccountOutOfSync,
        InstructionErrorType::Custom,
        InstructionErrorType::InvalidError,
        InstructionErrorType::ExecutableDataModified,
        InstructionErrorType::ExecutableLamportChange,
        InstructionErrorType::ExecutableAccountNotRentExempt,
        InstructionErrorType::UnsupportedProgramId,
        InstructionErrorType::CallDepth,
        InstructionErrorType::MissingAccount,
        InstructionErrorType::ReentrancyNotAllowed,
        InstructionErrorType::MaxSeedLengthExceeded,
        InstructionErrorType::InvalidSeeds,
        InstructionErrorType::InvalidRealloc,
        InstructionErrorType::ComputationalBudgetExceeded,
        InstructionErrorType::PrivilegeEscalation,
        InstructionErrorType::ProgramEnvironmentSetupFailure,
        InstructionErrorType::ProgramFailedToComplete,
        InstructionErrorType::ProgramFailedToCompile,
        InstructionErrorType::Immutable,
        InstructionErrorType::IncorrectAuthority,
        InstructionErrorType::BorshIoError,
        InstructionErrorType::AccountNotRentExempt,
        InstructionErrorType::InvalidAccountOwner,
        InstructionErrorType::ArithmeticOverflow,
        InstructionErrorType::UnsupportedSysvar,
        InstructionErrorType::IllegalOwner,
        InstructionErrorType::MaxAccountsDataSizeExceeded,
        InstructionErrorType::MaxAccountsExceeded,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct InstructionErrorType(pub u8);
    #[allow(non_upper_case_globals)]
    impl InstructionErrorType {
        pub const GenericError: Self = Self(0);
        pub const InvalidArgument: Self = Self(1);
        pub const InvalidInstructionData: Self = Self(2);
        pub const InvalidAccountData: Self = Self(3);
        pub const AccountDataTooSmall: Self = Self(4);
        pub const InsufficientFunds: Self = Self(5);
        pub const IncorrectProgramId: Self = Self(6);
        pub const MissingRequiredSignature: Self = Self(7);
        pub const AccountAlreadyInitialized: Self = Self(8);
        pub const UninitializedAccount: Self = Self(9);
        pub const UnbalancedInstruction: Self = Self(10);
        pub const ModifiedProgramId: Self = Self(11);
        pub const ExternalAccountLamportSpend: Self = Self(12);
        pub const ExternalAccountDataModified: Self = Self(13);
        pub const ReadonlyLamportChange: Self = Self(14);
        pub const ReadonlyDataModified: Self = Self(15);
        pub const DuplicateAccountIndex: Self = Self(16);
        pub const ExecutableModified: Self = Self(17);
        pub const RentEpochModified: Self = Self(18);
        pub const NotEnoughAccountKeys: Self = Self(19);
        pub const AccountDataSizeChanged: Self = Self(20);
        pub const AccountNotExecutable: Self = Self(21);
        pub const AccountBorrowFailed: Self = Self(22);
        pub const AccountBorrowOutstanding: Self = Self(23);
        pub const DuplicateAccountOutOfSync: Self = Self(24);
        pub const Custom: Self = Self(25);
        pub const InvalidError: Self = Self(26);
        pub const ExecutableDataModified: Self = Self(27);
        pub const ExecutableLamportChange: Self = Self(28);
        pub const ExecutableAccountNotRentExempt: Self = Self(29);
        pub const UnsupportedProgramId: Self = Self(30);
        pub const CallDepth: Self = Self(31);
        pub const MissingAccount: Self = Self(32);
        pub const ReentrancyNotAllowed: Self = Self(33);
        pub const MaxSeedLengthExceeded: Self = Self(34);
        pub const InvalidSeeds: Self = Self(35);
        pub const InvalidRealloc: Self = Self(36);
        pub const ComputationalBudgetExceeded: Self = Self(37);
        pub const PrivilegeEscalation: Self = Self(38);
        pub const ProgramEnvironmentSetupFailure: Self = Self(39);
        pub const ProgramFailedToComplete: Self = Self(40);
        pub const ProgramFailedToCompile: Self = Self(41);
        pub const Immutable: Self = Self(42);
        pub const IncorrectAuthority: Self = Self(43);
        pub const BorshIoError: Self = Self(44);
        pub const AccountNotRentExempt: Self = Self(45);
        pub const InvalidAccountOwner: Self = Self(46);
        pub const ArithmeticOverflow: Self = Self(47);
        pub const UnsupportedSysvar: Self = Self(48);
        pub const IllegalOwner: Self = Self(49);
        pub const MaxAccountsDataSizeExceeded: Self = Self(50);
        pub const MaxAccountsExceeded: Self = Self(51);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 51;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::GenericError,
            Self::InvalidArgument,
            Self::InvalidInstructionData,
            Self::InvalidAccountData,
            Self::AccountDataTooSmall,
            Self::InsufficientFunds,
            Self::IncorrectProgramId,
            Self::MissingRequiredSignature,
            Self::AccountAlreadyInitialized,
            Self::UninitializedAccount,
            Self::UnbalancedInstruction,
            Self::ModifiedProgramId,
            Self::ExternalAccountLamportSpend,
            Self::ExternalAccountDataModified,
            Self::ReadonlyLamportChange,
            Self::ReadonlyDataModified,
            Self::DuplicateAccountIndex,
            Self::ExecutableModified,
            Self::RentEpochModified,
            Self::NotEnoughAccountKeys,
            Self::AccountDataSizeChanged,
            Self::AccountNotExecutable,
            Self::AccountBorrowFailed,
            Self::AccountBorrowOutstanding,
            Self::DuplicateAccountOutOfSync,
            Self::Custom,
            Self::InvalidError,
            Self::ExecutableDataModified,
            Self::ExecutableLamportChange,
            Self::ExecutableAccountNotRentExempt,
            Self::UnsupportedProgramId,
            Self::CallDepth,
            Self::MissingAccount,
            Self::ReentrancyNotAllowed,
            Self::MaxSeedLengthExceeded,
            Self::InvalidSeeds,
            Self::InvalidRealloc,
            Self::ComputationalBudgetExceeded,
            Self::PrivilegeEscalation,
            Self::ProgramEnvironmentSetupFailure,
            Self::ProgramFailedToComplete,
            Self::ProgramFailedToCompile,
            Self::Immutable,
            Self::IncorrectAuthority,
            Self::BorshIoError,
            Self::AccountNotRentExempt,
            Self::InvalidAccountOwner,
            Self::ArithmeticOverflow,
            Self::UnsupportedSysvar,
            Self::IllegalOwner,
            Self::MaxAccountsDataSizeExceeded,
            Self::MaxAccountsExceeded,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::GenericError => Some("GenericError"),
                Self::InvalidArgument => Some("InvalidArgument"),
                Self::InvalidInstructionData => Some("InvalidInstructionData"),
                Self::InvalidAccountData => Some("InvalidAccountData"),
                Self::AccountDataTooSmall => Some("AccountDataTooSmall"),
                Self::InsufficientFunds => Some("InsufficientFunds"),
                Self::IncorrectProgramId => Some("IncorrectProgramId"),
                Self::MissingRequiredSignature => Some("MissingRequiredSignature"),
                Self::AccountAlreadyInitialized => Some("AccountAlreadyInitialized"),
                Self::UninitializedAccount => Some("UninitializedAccount"),
                Self::UnbalancedInstruction => Some("UnbalancedInstruction"),
                Self::ModifiedProgramId => Some("ModifiedProgramId"),
                Self::ExternalAccountLamportSpend => Some("ExternalAccountLamportSpend"),
                Self::ExternalAccountDataModified => Some("ExternalAccountDataModified"),
                Self::ReadonlyLamportChange => Some("ReadonlyLamportChange"),
                Self::ReadonlyDataModified => Some("ReadonlyDataModified"),
                Self::DuplicateAccountIndex => Some("DuplicateAccountIndex"),
                Self::ExecutableModified => Some("ExecutableModified"),
                Self::RentEpochModified => Some("RentEpochModified"),
                Self::NotEnoughAccountKeys => Some("NotEnoughAccountKeys"),
                Self::AccountDataSizeChanged => Some("AccountDataSizeChanged"),
                Self::AccountNotExecutable => Some("AccountNotExecutable"),
                Self::AccountBorrowFailed => Some("AccountBorrowFailed"),
                Self::AccountBorrowOutstanding => Some("AccountBorrowOutstanding"),
                Self::DuplicateAccountOutOfSync => Some("DuplicateAccountOutOfSync"),
                Self::Custom => Some("Custom"),
                Self::InvalidError => Some("InvalidError"),
                Self::ExecutableDataModified => Some("ExecutableDataModified"),
                Self::ExecutableLamportChange => Some("ExecutableLamportChange"),
                Self::ExecutableAccountNotRentExempt => Some("ExecutableAccountNotRentExempt"),
                Self::UnsupportedProgramId => Some("UnsupportedProgramId"),
                Self::CallDepth => Some("CallDepth"),
                Self::MissingAccount => Some("MissingAccount"),
                Self::ReentrancyNotAllowed => Some("ReentrancyNotAllowed"),
                Self::MaxSeedLengthExceeded => Some("MaxSeedLengthExceeded"),
                Self::InvalidSeeds => Some("InvalidSeeds"),
                Self::InvalidRealloc => Some("InvalidRealloc"),
                Self::ComputationalBudgetExceeded => Some("ComputationalBudgetExceeded"),
                Self::PrivilegeEscalation => Some("PrivilegeEscalation"),
                Self::ProgramEnvironmentSetupFailure => Some("ProgramEnvironmentSetupFailure"),
                Self::ProgramFailedToComplete => Some("ProgramFailedToComplete"),
                Self::ProgramFailedToCompile => Some("ProgramFailedToCompile"),
                Self::Immutable => Some("Immutable"),
                Self::IncorrectAuthority => Some("IncorrectAuthority"),
                Self::BorshIoError => Some("BorshIoError"),
                Self::AccountNotRentExempt => Some("AccountNotRentExempt"),
                Self::InvalidAccountOwner => Some("InvalidAccountOwner"),
                Self::ArithmeticOverflow => Some("ArithmeticOverflow"),
                Self::UnsupportedSysvar => Some("UnsupportedSysvar"),
                Self::IllegalOwner => Some("IllegalOwner"),
                Self::MaxAccountsDataSizeExceeded => Some("MaxAccountsDataSizeExceeded"),
                Self::MaxAccountsExceeded => Some("MaxAccountsExceeded"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for InstructionErrorType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for InstructionErrorType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for InstructionErrorType {
        type Output = InstructionErrorType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for InstructionErrorType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for InstructionErrorType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for InstructionErrorType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TRANSACTION_ERROR_DATA: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TRANSACTION_ERROR_DATA: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TRANSACTION_ERROR_DATA: [TransactionErrorData; 3] = [
        TransactionErrorData::NONE,
        TransactionErrorData::InstructionError,
        TransactionErrorData::InnerByte,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TransactionErrorData(pub u8);
    #[allow(non_upper_case_globals)]
    impl TransactionErrorData {
        pub const NONE: Self = Self(0);
        pub const InstructionError: Self = Self(1);
        pub const InnerByte: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::NONE, Self::InstructionError, Self::InnerByte];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::InstructionError => Some("InstructionError"),
                Self::InnerByte => Some("InnerByte"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TransactionErrorData {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TransactionErrorData {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TransactionErrorData {
        type Output = TransactionErrorData;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TransactionErrorData {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TransactionErrorData {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TransactionErrorData {}
    pub struct TransactionErrorDataUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_INSTRUCTION_ERROR_INNER_DATA: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_INSTRUCTION_ERROR_INNER_DATA: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_INSTRUCTION_ERROR_INNER_DATA: [InstructionErrorInnerData; 3] = [
        InstructionErrorInnerData::NONE,
        InstructionErrorInnerData::BorshIoError,
        InstructionErrorInnerData::Custom,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct InstructionErrorInnerData(pub u8);
    #[allow(non_upper_case_globals)]
    impl InstructionErrorInnerData {
        pub const NONE: Self = Self(0);
        pub const BorshIoError: Self = Self(1);
        pub const Custom: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::BorshIoError, Self::Custom];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::BorshIoError => Some("BorshIoError"),
                Self::Custom => Some("Custom"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for InstructionErrorInnerData {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for InstructionErrorInnerData {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for InstructionErrorInnerData {
        type Output = InstructionErrorInnerData;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for InstructionErrorInnerData {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for InstructionErrorInnerData {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for InstructionErrorInnerData {}
    pub struct InstructionErrorInnerDataUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_UI_RETURN_DATA_ENCODING: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_UI_RETURN_DATA_ENCODING: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_UI_RETURN_DATA_ENCODING: [UiReturnDataEncoding; 1] =
        [UiReturnDataEncoding::base64];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct UiReturnDataEncoding(pub u8);
    #[allow(non_upper_case_globals)]
    impl UiReturnDataEncoding {
        pub const base64: Self = Self(0);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 0;
        pub const ENUM_VALUES: &'static [Self] = &[Self::base64];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::base64 => Some("base64"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for UiReturnDataEncoding {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for UiReturnDataEncoding {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for UiReturnDataEncoding {
        type Output = UiReturnDataEncoding;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for UiReturnDataEncoding {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for UiReturnDataEncoding {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UiReturnDataEncoding {}
    pub enum TransactionInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionInfo<'a> {
        type Inner = TransactionInfo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionInfo<'a> {
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
        pub const VT_IS_VOTE: flatbuffers::VOffsetT = 6;
        pub const VT_SLOT: flatbuffers::VOffsetT = 8;
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 10;
        pub const VT_TRANSACTION_META: flatbuffers::VOffsetT = 12;
        pub const VT_LOADED_ADDRESSES: flatbuffers::VOffsetT = 14;
        pub const VT_ACCOUNT_KEYS: flatbuffers::VOffsetT = 16;
        pub const VT_MEMO: flatbuffers::VOffsetT = 18;
        pub const VT_RETURN_DATA: flatbuffers::VOffsetT = 20;
        pub const VT_COMPUTE_UNITS_CONSUMED: flatbuffers::VOffsetT = 22;
        pub const VT_INDEX: flatbuffers::VOffsetT = 24;
        pub const VT_SIGNATURE_STRING: flatbuffers::VOffsetT = 26;
        pub const VT_ACCOUNT_KEYS_STRING: flatbuffers::VOffsetT = 28;
        pub const VT_LOADED_ADDRESSES_STRING: flatbuffers::VOffsetT = 30;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionInfo<'bldr>> {
            let mut builder = TransactionInfoBuilder::new(_fbb);
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            if let Some(x) = args.compute_units_consumed {
                builder.add_compute_units_consumed(x);
            }
            builder.add_slot(args.slot);
            if let Some(x) = args.loaded_addresses_string {
                builder.add_loaded_addresses_string(x);
            }
            if let Some(x) = args.account_keys_string {
                builder.add_account_keys_string(x);
            }
            if let Some(x) = args.signature_string {
                builder.add_signature_string(x);
            }
            if let Some(x) = args.return_data {
                builder.add_return_data(x);
            }
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.account_keys {
                builder.add_account_keys(x);
            }
            if let Some(x) = args.loaded_addresses {
                builder.add_loaded_addresses(x);
            }
            if let Some(x) = args.transaction_meta {
                builder.add_transaction_meta(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            builder.add_is_vote(args.is_vote);
            builder.finish()
        }

        #[inline]
        pub fn signature(&self) -> Option<Signature<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Signature>>(
                    TransactionInfo::VT_SIGNATURE,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_vote(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(TransactionInfo::VT_IS_VOTE, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn slot(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TransactionInfo::VT_SLOT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn transaction(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionInfo::VT_TRANSACTION,
                        None,
                    )
            }
        }
        #[inline]
        pub fn transaction_meta(&self) -> Option<TransactionStatusMeta<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<TransactionStatusMeta>>(
                        TransactionInfo::VT_TRANSACTION_META,
                        None,
                    )
            }
        }
        #[inline]
        pub fn loaded_addresses(&self) -> Option<LoadedAddresses<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<LoadedAddresses>>(
                        TransactionInfo::VT_LOADED_ADDRESSES,
                        None,
                    )
            }
        }
        #[inline]
        pub fn account_keys(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>(TransactionInfo::VT_ACCOUNT_KEYS, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_MEMO, None)
            }
        }
        #[inline]
        pub fn return_data(&self) -> Option<TransactionReturnData<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<TransactionReturnData>>(
                        TransactionInfo::VT_RETURN_DATA,
                        None,
                    )
            }
        }
        #[inline]
        pub fn compute_units_consumed(&self) -> Option<u64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TransactionInfo::VT_COMPUTE_UNITS_CONSUMED, None)
            }
        }
        #[inline]
        pub fn index(&self) -> Option<u64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TransactionInfo::VT_INDEX, None) }
        }
        #[inline]
        pub fn signature_string(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionInfo::VT_SIGNATURE_STRING,
                    None,
                )
            }
        }
        #[inline]
        pub fn account_keys_string(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(TransactionInfo::VT_ACCOUNT_KEYS_STRING, None)
            }
        }
        #[inline]
        pub fn loaded_addresses_string(&self) -> Option<LoadedAddressesString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<LoadedAddressesString>>(
                        TransactionInfo::VT_LOADED_ADDRESSES_STRING,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Signature>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<bool>("is_vote", Self::VT_IS_VOTE, false)?
                .visit_field::<u64>("slot", Self::VT_SLOT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<TransactionStatusMeta>>(
                    "transaction_meta",
                    Self::VT_TRANSACTION_META,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<LoadedAddresses>>(
                    "loaded_addresses",
                    Self::VT_LOADED_ADDRESSES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("account_keys", Self::VT_ACCOUNT_KEYS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<TransactionReturnData>>(
                    "return_data",
                    Self::VT_RETURN_DATA,
                    false,
                )?
                .visit_field::<u64>(
                    "compute_units_consumed",
                    Self::VT_COMPUTE_UNITS_CONSUMED,
                    false,
                )?
                .visit_field::<u64>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "signature_string",
                    Self::VT_SIGNATURE_STRING,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("account_keys_string", Self::VT_ACCOUNT_KEYS_STRING, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<LoadedAddressesString>>(
                    "loaded_addresses_string",
                    Self::VT_LOADED_ADDRESSES_STRING,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionInfoArgs<'a> {
        pub signature: Option<flatbuffers::WIPOffset<Signature<'a>>>,
        pub is_vote: bool,
        pub slot: u64,
        pub transaction: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub transaction_meta: Option<flatbuffers::WIPOffset<TransactionStatusMeta<'a>>>,
        pub loaded_addresses: Option<flatbuffers::WIPOffset<LoadedAddresses<'a>>>,
        pub account_keys: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
        pub return_data: Option<flatbuffers::WIPOffset<TransactionReturnData<'a>>>,
        pub compute_units_consumed: Option<u64>,
        pub index: Option<u64>,
        pub signature_string: Option<flatbuffers::WIPOffset<&'a str>>,
        pub account_keys_string: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub loaded_addresses_string: Option<flatbuffers::WIPOffset<LoadedAddressesString<'a>>>,
    }
    impl<'a> Default for TransactionInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionInfoArgs {
                signature: None,
                is_vote: false,
                slot: 0,
                transaction: None,
                transaction_meta: None,
                loaded_addresses: None,
                account_keys: None,
                memo: None,
                return_data: None,
                compute_units_consumed: None,
                index: None,
                signature_string: None,
                account_keys_string: None,
                loaded_addresses_string: None,
            }
        }
    }

    pub struct TransactionInfoBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionInfoBuilder<'a, 'b> {
        #[inline]
        pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<Signature<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Signature>>(
                    TransactionInfo::VT_SIGNATURE,
                    signature,
                );
        }
        #[inline]
        pub fn add_is_vote(&mut self, is_vote: bool) {
            self.fbb_
                .push_slot::<bool>(TransactionInfo::VT_IS_VOTE, is_vote, false);
        }
        #[inline]
        pub fn add_slot(&mut self, slot: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionInfo::VT_SLOT, slot, 0);
        }
        #[inline]
        pub fn add_transaction(
            &mut self,
            transaction: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_transaction_meta(
            &mut self,
            transaction_meta: flatbuffers::WIPOffset<TransactionStatusMeta<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<TransactionStatusMeta>>(
                    TransactionInfo::VT_TRANSACTION_META,
                    transaction_meta,
                );
        }
        #[inline]
        pub fn add_loaded_addresses(
            &mut self,
            loaded_addresses: flatbuffers::WIPOffset<LoadedAddresses<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<LoadedAddresses>>(
                    TransactionInfo::VT_LOADED_ADDRESSES,
                    loaded_addresses,
                );
        }
        #[inline]
        pub fn add_account_keys(
            &mut self,
            account_keys: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_ACCOUNT_KEYS,
                account_keys,
            );
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_MEMO, memo);
        }
        #[inline]
        pub fn add_return_data(
            &mut self,
            return_data: flatbuffers::WIPOffset<TransactionReturnData<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<TransactionReturnData>>(
                    TransactionInfo::VT_RETURN_DATA,
                    return_data,
                );
        }
        #[inline]
        pub fn add_compute_units_consumed(&mut self, compute_units_consumed: u64) {
            self.fbb_.push_slot_always::<u64>(
                TransactionInfo::VT_COMPUTE_UNITS_CONSUMED,
                compute_units_consumed,
            );
        }
        #[inline]
        pub fn add_index(&mut self, index: u64) {
            self.fbb_
                .push_slot_always::<u64>(TransactionInfo::VT_INDEX, index);
        }
        #[inline]
        pub fn add_signature_string(&mut self, signature_string: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_SIGNATURE_STRING,
                signature_string,
            );
        }
        #[inline]
        pub fn add_account_keys_string(
            &mut self,
            account_keys_string: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_ACCOUNT_KEYS_STRING,
                account_keys_string,
            );
        }
        #[inline]
        pub fn add_loaded_addresses_string(
            &mut self,
            loaded_addresses_string: flatbuffers::WIPOffset<LoadedAddressesString<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<LoadedAddressesString>>(
                    TransactionInfo::VT_LOADED_ADDRESSES_STRING,
                    loaded_addresses_string,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionInfoBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionInfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionInfo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionInfo");
            ds.field("signature", &self.signature());
            ds.field("is_vote", &self.is_vote());
            ds.field("slot", &self.slot());
            ds.field("transaction", &self.transaction());
            ds.field("transaction_meta", &self.transaction_meta());
            ds.field("loaded_addresses", &self.loaded_addresses());
            ds.field("account_keys", &self.account_keys());
            ds.field("memo", &self.memo());
            ds.field("return_data", &self.return_data());
            ds.field("compute_units_consumed", &self.compute_units_consumed());
            ds.field("index", &self.index());
            ds.field("signature_string", &self.signature_string());
            ds.field("account_keys_string", &self.account_keys_string());
            ds.field("loaded_addresses_string", &self.loaded_addresses_string());
            ds.finish()
        }
    }
    pub enum LoadedAddressesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LoadedAddresses<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LoadedAddresses<'a> {
        type Inner = LoadedAddresses<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LoadedAddresses<'a> {
        pub const VT_WRITABLE: flatbuffers::VOffsetT = 4;
        pub const VT_READONLY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LoadedAddresses { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LoadedAddressesArgs<'args>,
        ) -> flatbuffers::WIPOffset<LoadedAddresses<'bldr>> {
            let mut builder = LoadedAddressesBuilder::new(_fbb);
            if let Some(x) = args.readonly {
                builder.add_readonly(x);
            }
            if let Some(x) = args.writable {
                builder.add_writable(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn writable(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>(LoadedAddresses::VT_WRITABLE, None)
            }
        }
        #[inline]
        pub fn readonly(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>(LoadedAddresses::VT_READONLY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for LoadedAddresses<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("writable", Self::VT_WRITABLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pubkey>>,
                >>("readonly", Self::VT_READONLY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LoadedAddressesArgs<'a> {
        pub writable: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
        pub readonly: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pubkey<'a>>>,
            >,
        >,
    }
    impl<'a> Default for LoadedAddressesArgs<'a> {
        #[inline]
        fn default() -> Self {
            LoadedAddressesArgs {
                writable: None,
                readonly: None,
            }
        }
    }

    pub struct LoadedAddressesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LoadedAddressesBuilder<'a, 'b> {
        #[inline]
        pub fn add_writable(
            &mut self,
            writable: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LoadedAddresses::VT_WRITABLE,
                writable,
            );
        }
        #[inline]
        pub fn add_readonly(
            &mut self,
            readonly: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Pubkey<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LoadedAddresses::VT_READONLY,
                readonly,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LoadedAddressesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LoadedAddressesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LoadedAddresses<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LoadedAddresses<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LoadedAddresses");
            ds.field("writable", &self.writable());
            ds.field("readonly", &self.readonly());
            ds.finish()
        }
    }
    pub enum LoadedAddressesStringOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LoadedAddressesString<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LoadedAddressesString<'a> {
        type Inner = LoadedAddressesString<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LoadedAddressesString<'a> {
        pub const VT_WRITABLE: flatbuffers::VOffsetT = 4;
        pub const VT_READONLY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LoadedAddressesString { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LoadedAddressesStringArgs<'args>,
        ) -> flatbuffers::WIPOffset<LoadedAddressesString<'bldr>> {
            let mut builder = LoadedAddressesStringBuilder::new(_fbb);
            if let Some(x) = args.readonly {
                builder.add_readonly(x);
            }
            if let Some(x) = args.writable {
                builder.add_writable(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn writable(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(LoadedAddressesString::VT_WRITABLE, None)
            }
        }
        #[inline]
        pub fn readonly(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(LoadedAddressesString::VT_READONLY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for LoadedAddressesString<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("writable", Self::VT_WRITABLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("readonly", Self::VT_READONLY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LoadedAddressesStringArgs<'a> {
        pub writable: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub readonly: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for LoadedAddressesStringArgs<'a> {
        #[inline]
        fn default() -> Self {
            LoadedAddressesStringArgs {
                writable: None,
                readonly: None,
            }
        }
    }

    pub struct LoadedAddressesStringBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LoadedAddressesStringBuilder<'a, 'b> {
        #[inline]
        pub fn add_writable(
            &mut self,
            writable: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LoadedAddressesString::VT_WRITABLE,
                writable,
            );
        }
        #[inline]
        pub fn add_readonly(
            &mut self,
            readonly: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LoadedAddressesString::VT_READONLY,
                readonly,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LoadedAddressesStringBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LoadedAddressesStringBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LoadedAddressesString<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LoadedAddressesString<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LoadedAddressesString");
            ds.field("writable", &self.writable());
            ds.field("readonly", &self.readonly());
            ds.finish()
        }
    }
    pub enum CompiledInstructionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CompiledInstruction<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CompiledInstruction<'a> {
        type Inner = CompiledInstruction<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CompiledInstruction<'a> {
        pub const VT_PROGRAM_ID_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 6;
        pub const VT_DATA: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CompiledInstruction { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CompiledInstructionArgs<'args>,
        ) -> flatbuffers::WIPOffset<CompiledInstruction<'bldr>> {
            let mut builder = CompiledInstructionBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            if let Some(x) = args.accounts {
                builder.add_accounts(x);
            }
            builder.add_program_id_index(args.program_id_index);
            builder.finish()
        }

        #[inline]
        pub fn program_id_index(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(CompiledInstruction::VT_PROGRAM_ID_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn accounts(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CompiledInstruction::VT_ACCOUNTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CompiledInstruction::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for CompiledInstruction<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("program_id_index", Self::VT_PROGRAM_ID_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "accounts",
                    Self::VT_ACCOUNTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CompiledInstructionArgs<'a> {
        pub program_id_index: u8,
        pub accounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CompiledInstructionArgs<'a> {
        #[inline]
        fn default() -> Self {
            CompiledInstructionArgs {
                program_id_index: 0,
                accounts: None,
                data: None,
            }
        }
    }

    pub struct CompiledInstructionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CompiledInstructionBuilder<'a, 'b> {
        #[inline]
        pub fn add_program_id_index(&mut self, program_id_index: u8) {
            self.fbb_.push_slot::<u8>(
                CompiledInstruction::VT_PROGRAM_ID_INDEX,
                program_id_index,
                0,
            );
        }
        #[inline]
        pub fn add_accounts(
            &mut self,
            accounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                CompiledInstruction::VT_ACCOUNTS,
                accounts,
            );
        }
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CompiledInstruction::VT_DATA, data);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CompiledInstructionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CompiledInstructionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CompiledInstruction<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CompiledInstruction<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CompiledInstruction");
            ds.field("program_id_index", &self.program_id_index());
            ds.field("accounts", &self.accounts());
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum InstructionErrorDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InstructionErrorData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InstructionErrorData<'a> {
        type Inner = InstructionErrorData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InstructionErrorData<'a> {
        pub const VT_INSTRUCTION_NUMBER: flatbuffers::VOffsetT = 4;
        pub const VT_ERR: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InstructionErrorData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InstructionErrorDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<InstructionErrorData<'bldr>> {
            let mut builder = InstructionErrorDataBuilder::new(_fbb);
            if let Some(x) = args.err {
                builder.add_err(x);
            }
            builder.add_instruction_number(args.instruction_number);
            builder.finish()
        }

        #[inline]
        pub fn instruction_number(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(InstructionErrorData::VT_INSTRUCTION_NUMBER, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn err(&self) -> Option<InstructionError<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<InstructionError>>(
                        InstructionErrorData::VT_ERR,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for InstructionErrorData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("instruction_number", Self::VT_INSTRUCTION_NUMBER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<InstructionError>>(
                    "err",
                    Self::VT_ERR,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct InstructionErrorDataArgs<'a> {
        pub instruction_number: u8,
        pub err: Option<flatbuffers::WIPOffset<InstructionError<'a>>>,
    }
    impl<'a> Default for InstructionErrorDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            InstructionErrorDataArgs {
                instruction_number: 0,
                err: None,
            }
        }
    }

    pub struct InstructionErrorDataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InstructionErrorDataBuilder<'a, 'b> {
        #[inline]
        pub fn add_instruction_number(&mut self, instruction_number: u8) {
            self.fbb_.push_slot::<u8>(
                InstructionErrorData::VT_INSTRUCTION_NUMBER,
                instruction_number,
                0,
            );
        }
        #[inline]
        pub fn add_err(&mut self, err: flatbuffers::WIPOffset<InstructionError<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<InstructionError>>(
                    InstructionErrorData::VT_ERR,
                    err,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> InstructionErrorDataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InstructionErrorDataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InstructionErrorData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InstructionErrorData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InstructionErrorData");
            ds.field("instruction_number", &self.instruction_number());
            ds.field("err", &self.err());
            ds.finish()
        }
    }
    pub enum InnerByteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InnerByte<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InnerByte<'a> {
        type Inner = InnerByte<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InnerByte<'a> {
        pub const VT_INNER_BYTE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InnerByte { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InnerByteArgs,
        ) -> flatbuffers::WIPOffset<InnerByte<'bldr>> {
            let mut builder = InnerByteBuilder::new(_fbb);
            builder.add_inner_byte(args.inner_byte);
            builder.finish()
        }

        #[inline]
        pub fn inner_byte(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(InnerByte::VT_INNER_BYTE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for InnerByte<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("inner_byte", Self::VT_INNER_BYTE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct InnerByteArgs {
        pub inner_byte: u8,
    }
    impl<'a> Default for InnerByteArgs {
        #[inline]
        fn default() -> Self {
            InnerByteArgs { inner_byte: 0 }
        }
    }

    pub struct InnerByteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InnerByteBuilder<'a, 'b> {
        #[inline]
        pub fn add_inner_byte(&mut self, inner_byte: u8) {
            self.fbb_
                .push_slot::<u8>(InnerByte::VT_INNER_BYTE, inner_byte, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InnerByteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InnerByteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InnerByte<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InnerByte<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InnerByte");
            ds.field("inner_byte", &self.inner_byte());
            ds.finish()
        }
    }
    pub enum StringValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringValue<'a> {
        type Inner = StringValue<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> StringValue<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringValue<'bldr>> {
            let mut builder = StringValueBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(StringValue::VT_VALUE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for StringValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringValueArgs<'a> {
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for StringValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringValueArgs { value: None }
        }
    }

    pub struct StringValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringValue::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for StringValue<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("StringValue");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum Uint32ValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Uint32Value<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Uint32Value<'a> {
        type Inner = Uint32Value<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Uint32Value<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Uint32Value { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Uint32ValueArgs,
        ) -> flatbuffers::WIPOffset<Uint32Value<'bldr>> {
            let mut builder = Uint32ValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Uint32Value::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Uint32Value<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct Uint32ValueArgs {
        pub value: u32,
    }
    impl<'a> Default for Uint32ValueArgs {
        #[inline]
        fn default() -> Self {
            Uint32ValueArgs { value: 0 }
        }
    }

    pub struct Uint32ValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Uint32ValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: u32) {
            self.fbb_.push_slot::<u32>(Uint32Value::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint32ValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Uint32ValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Uint32Value<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Uint32Value<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Uint32Value");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum InstructionErrorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InstructionError<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InstructionError<'a> {
        type Inner = InstructionError<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InstructionError<'a> {
        pub const VT_ERR_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_ERR_DATA_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ERR_DATA: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InstructionError { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InstructionErrorArgs,
        ) -> flatbuffers::WIPOffset<InstructionError<'bldr>> {
            let mut builder = InstructionErrorBuilder::new(_fbb);
            if let Some(x) = args.err_data {
                builder.add_err_data(x);
            }
            builder.add_err_data_type(args.err_data_type);
            builder.add_err_type(args.err_type);
            builder.finish()
        }

        #[inline]
        pub fn err_type(&self) -> InstructionErrorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<InstructionErrorType>(
                        InstructionError::VT_ERR_TYPE,
                        Some(InstructionErrorType::GenericError),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn err_data_type(&self) -> InstructionErrorInnerData {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<InstructionErrorInnerData>(
                        InstructionError::VT_ERR_DATA_TYPE,
                        Some(InstructionErrorInnerData::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn err_data(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        InstructionError::VT_ERR_DATA,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn err_data_as_borsh_io_error(&self) -> Option<StringValue<'a>> {
            if self.err_data_type() == InstructionErrorInnerData::BorshIoError {
                self.err_data().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { StringValue::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn err_data_as_custom(&self) -> Option<Uint32Value<'a>> {
            if self.err_data_type() == InstructionErrorInnerData::Custom {
                self.err_data().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Uint32Value::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for InstructionError<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<InstructionErrorType>("err_type", Self::VT_ERR_TYPE, false)?
                .visit_union::<InstructionErrorInnerData, _>(
                    "err_data_type",
                    Self::VT_ERR_DATA_TYPE,
                    "err_data",
                    Self::VT_ERR_DATA,
                    false,
                    |key, v, pos| match key {
                        InstructionErrorInnerData::BorshIoError => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<StringValue>>(
                                "InstructionErrorInnerData::BorshIoError",
                                pos,
                            ),
                        InstructionErrorInnerData::Custom => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Uint32Value>>(
                                "InstructionErrorInnerData::Custom",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct InstructionErrorArgs {
        pub err_type: InstructionErrorType,
        pub err_data_type: InstructionErrorInnerData,
        pub err_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for InstructionErrorArgs {
        #[inline]
        fn default() -> Self {
            InstructionErrorArgs {
                err_type: InstructionErrorType::GenericError,
                err_data_type: InstructionErrorInnerData::NONE,
                err_data: None,
            }
        }
    }

    pub struct InstructionErrorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InstructionErrorBuilder<'a, 'b> {
        #[inline]
        pub fn add_err_type(&mut self, err_type: InstructionErrorType) {
            self.fbb_.push_slot::<InstructionErrorType>(
                InstructionError::VT_ERR_TYPE,
                err_type,
                InstructionErrorType::GenericError,
            );
        }
        #[inline]
        pub fn add_err_data_type(&mut self, err_data_type: InstructionErrorInnerData) {
            self.fbb_.push_slot::<InstructionErrorInnerData>(
                InstructionError::VT_ERR_DATA_TYPE,
                err_data_type,
                InstructionErrorInnerData::NONE,
            );
        }
        #[inline]
        pub fn add_err_data(
            &mut self,
            err_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                InstructionError::VT_ERR_DATA,
                err_data,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> InstructionErrorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InstructionErrorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InstructionError<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InstructionError<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InstructionError");
            ds.field("err_type", &self.err_type());
            ds.field("err_data_type", &self.err_data_type());
            match self.err_data_type() {
                InstructionErrorInnerData::BorshIoError => {
                    if let Some(x) = self.err_data_as_borsh_io_error() {
                        ds.field("err_data", &x)
                    } else {
                        ds.field(
                            "err_data",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                InstructionErrorInnerData::Custom => {
                    if let Some(x) = self.err_data_as_custom() {
                        ds.field("err_data", &x)
                    } else {
                        ds.field(
                            "err_data",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("err_data", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum TransactionErrorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionError<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionError<'a> {
        type Inner = TransactionError<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionError<'a> {
        pub const VT_ERR_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_ERR_DATA_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ERR_DATA: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionError { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionErrorArgs,
        ) -> flatbuffers::WIPOffset<TransactionError<'bldr>> {
            let mut builder = TransactionErrorBuilder::new(_fbb);
            if let Some(x) = args.err_data {
                builder.add_err_data(x);
            }
            builder.add_err_data_type(args.err_data_type);
            builder.add_err_type(args.err_type);
            builder.finish()
        }

        #[inline]
        pub fn err_type(&self) -> TransactionErrorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TransactionErrorType>(
                        TransactionError::VT_ERR_TYPE,
                        Some(TransactionErrorType::AccountInUse),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn err_data_type(&self) -> TransactionErrorData {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TransactionErrorData>(
                        TransactionError::VT_ERR_DATA_TYPE,
                        Some(TransactionErrorData::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn err_data(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        TransactionError::VT_ERR_DATA,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn err_data_as_instruction_error(&self) -> Option<InstructionErrorData<'a>> {
            if self.err_data_type() == TransactionErrorData::InstructionError {
                self.err_data().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { InstructionErrorData::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn err_data_as_inner_byte(&self) -> Option<InnerByte<'a>> {
            if self.err_data_type() == TransactionErrorData::InnerByte {
                self.err_data().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { InnerByte::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionError<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<TransactionErrorType>("err_type", Self::VT_ERR_TYPE, false)?
     .visit_union::<TransactionErrorData, _>("err_data_type", Self::VT_ERR_DATA_TYPE, "err_data", Self::VT_ERR_DATA, false, |key, v, pos| {
        match key {
          TransactionErrorData::InstructionError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InstructionErrorData>>("TransactionErrorData::InstructionError", pos),
          TransactionErrorData::InnerByte => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InnerByte>>("TransactionErrorData::InnerByte", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct TransactionErrorArgs {
        pub err_type: TransactionErrorType,
        pub err_data_type: TransactionErrorData,
        pub err_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for TransactionErrorArgs {
        #[inline]
        fn default() -> Self {
            TransactionErrorArgs {
                err_type: TransactionErrorType::AccountInUse,
                err_data_type: TransactionErrorData::NONE,
                err_data: None,
            }
        }
    }

    pub struct TransactionErrorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionErrorBuilder<'a, 'b> {
        #[inline]
        pub fn add_err_type(&mut self, err_type: TransactionErrorType) {
            self.fbb_.push_slot::<TransactionErrorType>(
                TransactionError::VT_ERR_TYPE,
                err_type,
                TransactionErrorType::AccountInUse,
            );
        }
        #[inline]
        pub fn add_err_data_type(&mut self, err_data_type: TransactionErrorData) {
            self.fbb_.push_slot::<TransactionErrorData>(
                TransactionError::VT_ERR_DATA_TYPE,
                err_data_type,
                TransactionErrorData::NONE,
            );
        }
        #[inline]
        pub fn add_err_data(
            &mut self,
            err_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionError::VT_ERR_DATA,
                err_data,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionErrorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionErrorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionError<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionError<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionError");
            ds.field("err_type", &self.err_type());
            ds.field("err_data_type", &self.err_data_type());
            match self.err_data_type() {
                TransactionErrorData::InstructionError => {
                    if let Some(x) = self.err_data_as_instruction_error() {
                        ds.field("err_data", &x)
                    } else {
                        ds.field(
                            "err_data",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TransactionErrorData::InnerByte => {
                    if let Some(x) = self.err_data_as_inner_byte() {
                        ds.field("err_data", &x)
                    } else {
                        ds.field(
                            "err_data",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("err_data", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum TransactionReturnDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionReturnData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionReturnData<'a> {
        type Inner = TransactionReturnData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionReturnData<'a> {
        pub const VT_PROGRAM_ID: flatbuffers::VOffsetT = 4;
        pub const VT_DATA_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionReturnData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionReturnDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionReturnData<'bldr>> {
            let mut builder = TransactionReturnDataBuilder::new(_fbb);
            if let Some(x) = args.data_value {
                builder.add_data_value(x);
            }
            if let Some(x) = args.program_id {
                builder.add_program_id(x);
            }
            builder.add_data_encoding(args.data_encoding);
            builder.finish()
        }

        #[inline]
        pub fn program_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionReturnData::VT_PROGRAM_ID,
                    None,
                )
            }
        }
        #[inline]
        pub fn data_value(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionReturnData::VT_DATA_VALUE,
                    None,
                )
            }
        }
        #[inline]
        pub fn data_encoding(&self) -> UiReturnDataEncoding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<UiReturnDataEncoding>(
                        TransactionReturnData::VT_DATA_ENCODING,
                        Some(UiReturnDataEncoding::base64),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionReturnData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "program_id",
                    Self::VT_PROGRAM_ID,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "data_value",
                    Self::VT_DATA_VALUE,
                    false,
                )?
                .visit_field::<UiReturnDataEncoding>(
                    "data_encoding",
                    Self::VT_DATA_ENCODING,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionReturnDataArgs<'a> {
        pub program_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub data_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub data_encoding: UiReturnDataEncoding,
    }
    impl<'a> Default for TransactionReturnDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionReturnDataArgs {
                program_id: None,
                data_value: None,
                data_encoding: UiReturnDataEncoding::base64,
            }
        }
    }

    pub struct TransactionReturnDataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionReturnDataBuilder<'a, 'b> {
        #[inline]
        pub fn add_program_id(&mut self, program_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionReturnData::VT_PROGRAM_ID,
                program_id,
            );
        }
        #[inline]
        pub fn add_data_value(&mut self, data_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionReturnData::VT_DATA_VALUE,
                data_value,
            );
        }
        #[inline]
        pub fn add_data_encoding(&mut self, data_encoding: UiReturnDataEncoding) {
            self.fbb_.push_slot::<UiReturnDataEncoding>(
                TransactionReturnData::VT_DATA_ENCODING,
                data_encoding,
                UiReturnDataEncoding::base64,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionReturnDataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionReturnDataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionReturnData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionReturnData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionReturnData");
            ds.field("program_id", &self.program_id());
            ds.field("data_value", &self.data_value());
            ds.field("data_encoding", &self.data_encoding());
            ds.finish()
        }
    }
    pub enum TransactionStatusMetaOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionStatusMeta<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionStatusMeta<'a> {
        type Inner = TransactionStatusMeta<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionStatusMeta<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_FEE: flatbuffers::VOffsetT = 6;
        pub const VT_PRE_BALANCES: flatbuffers::VOffsetT = 8;
        pub const VT_POST_BALANCES: flatbuffers::VOffsetT = 10;
        pub const VT_INNER_INSTRUCTIONS: flatbuffers::VOffsetT = 12;
        pub const VT_LOG_MESSAGES: flatbuffers::VOffsetT = 14;
        pub const VT_PRE_TOKEN_BALANCES: flatbuffers::VOffsetT = 16;
        pub const VT_POST_TOKEN_BALANCES: flatbuffers::VOffsetT = 18;
        pub const VT_REWARDS: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionStatusMeta { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionStatusMetaArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionStatusMeta<'bldr>> {
            let mut builder = TransactionStatusMetaBuilder::new(_fbb);
            builder.add_fee(args.fee);
            if let Some(x) = args.rewards {
                builder.add_rewards(x);
            }
            if let Some(x) = args.post_token_balances {
                builder.add_post_token_balances(x);
            }
            if let Some(x) = args.pre_token_balances {
                builder.add_pre_token_balances(x);
            }
            if let Some(x) = args.log_messages {
                builder.add_log_messages(x);
            }
            if let Some(x) = args.inner_instructions {
                builder.add_inner_instructions(x);
            }
            if let Some(x) = args.post_balances {
                builder.add_post_balances(x);
            }
            if let Some(x) = args.pre_balances {
                builder.add_pre_balances(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn status(&self) -> Option<TransactionError<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<TransactionError>>(
                        TransactionStatusMeta::VT_STATUS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TransactionStatusMeta::VT_FEE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn pre_balances(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                        TransactionStatusMeta::VT_PRE_BALANCES,
                        None,
                    )
            }
        }
        #[inline]
        pub fn post_balances(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                        TransactionStatusMeta::VT_POST_BALANCES,
                        None,
                    )
            }
        }
        #[inline]
        pub fn inner_instructions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InnerInstructions<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InnerInstructions>>,
                >>(TransactionStatusMeta::VT_INNER_INSTRUCTIONS, None)
            }
        }
        #[inline]
        pub fn log_messages(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(TransactionStatusMeta::VT_LOG_MESSAGES, None)
            }
        }
        #[inline]
        pub fn pre_token_balances(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
        > {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
                >>(TransactionStatusMeta::VT_PRE_TOKEN_BALANCES, None)
            }
        }
        #[inline]
        pub fn post_token_balances(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
        > {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
                >>(TransactionStatusMeta::VT_POST_TOKEN_BALANCES, None)
            }
        }
        #[inline]
        pub fn rewards(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Reward<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Reward>>,
                >>(TransactionStatusMeta::VT_REWARDS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionStatusMeta<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<TransactionError>>(
                    "status",
                    Self::VT_STATUS,
                    false,
                )?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                    "pre_balances",
                    Self::VT_PRE_BALANCES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                    "post_balances",
                    Self::VT_POST_BALANCES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InnerInstructions>>,
                >>("inner_instructions", Self::VT_INNER_INSTRUCTIONS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("log_messages", Self::VT_LOG_MESSAGES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
                >>("pre_token_balances", Self::VT_PRE_TOKEN_BALANCES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransactionTokenBalance>>,
                >>("post_token_balances", Self::VT_POST_TOKEN_BALANCES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Reward>>,
                >>("rewards", Self::VT_REWARDS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionStatusMetaArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<TransactionError<'a>>>,
        pub fee: u64,
        pub pre_balances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
        pub post_balances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
        pub inner_instructions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InnerInstructions<'a>>>,
            >,
        >,
        pub log_messages: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub pre_token_balances: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
            >,
        >,
        pub post_token_balances: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'a>>>,
            >,
        >,
        pub rewards: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Reward<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TransactionStatusMetaArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionStatusMetaArgs {
                status: None,
                fee: 0,
                pre_balances: None,
                post_balances: None,
                inner_instructions: None,
                log_messages: None,
                pre_token_balances: None,
                post_token_balances: None,
                rewards: None,
            }
        }
    }

    pub struct TransactionStatusMetaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionStatusMetaBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<TransactionError<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<TransactionError>>(
                    TransactionStatusMeta::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionStatusMeta::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn add_pre_balances(
            &mut self,
            pre_balances: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_PRE_BALANCES,
                pre_balances,
            );
        }
        #[inline]
        pub fn add_post_balances(
            &mut self,
            post_balances: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_POST_BALANCES,
                post_balances,
            );
        }
        #[inline]
        pub fn add_inner_instructions(
            &mut self,
            inner_instructions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InnerInstructions<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_INNER_INSTRUCTIONS,
                inner_instructions,
            );
        }
        #[inline]
        pub fn add_log_messages(
            &mut self,
            log_messages: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_LOG_MESSAGES,
                log_messages,
            );
        }
        #[inline]
        pub fn add_pre_token_balances(
            &mut self,
            pre_token_balances: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_PRE_TOKEN_BALANCES,
                pre_token_balances,
            );
        }
        #[inline]
        pub fn add_post_token_balances(
            &mut self,
            post_token_balances: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransactionTokenBalance<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_POST_TOKEN_BALANCES,
                post_token_balances,
            );
        }
        #[inline]
        pub fn add_rewards(
            &mut self,
            rewards: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Reward<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionStatusMeta::VT_REWARDS,
                rewards,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionStatusMetaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionStatusMetaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionStatusMeta<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionStatusMeta<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionStatusMeta");
            ds.field("status", &self.status());
            ds.field("fee", &self.fee());
            ds.field("pre_balances", &self.pre_balances());
            ds.field("post_balances", &self.post_balances());
            ds.field("inner_instructions", &self.inner_instructions());
            ds.field("log_messages", &self.log_messages());
            ds.field("pre_token_balances", &self.pre_token_balances());
            ds.field("post_token_balances", &self.post_token_balances());
            ds.field("rewards", &self.rewards());
            ds.finish()
        }
    }
    pub enum InnerInstructionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InnerInstructions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InnerInstructions<'a> {
        type Inner = InnerInstructions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InnerInstructions<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_INSTRUCTIONS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InnerInstructions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InnerInstructionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<InnerInstructions<'bldr>> {
            let mut builder = InnerInstructionsBuilder::new(_fbb);
            if let Some(x) = args.instructions {
                builder.add_instructions(x);
            }
            builder.add_index(args.index);
            builder.finish()
        }

        #[inline]
        pub fn index(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(InnerInstructions::VT_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn instructions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
                >>(InnerInstructions::VT_INSTRUCTIONS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for InnerInstructions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CompiledInstruction>>,
                >>("instructions", Self::VT_INSTRUCTIONS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct InnerInstructionsArgs<'a> {
        pub index: u8,
        pub instructions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompiledInstruction<'a>>>,
            >,
        >,
    }
    impl<'a> Default for InnerInstructionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            InnerInstructionsArgs {
                index: 0,
                instructions: None,
            }
        }
    }

    pub struct InnerInstructionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InnerInstructionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_index(&mut self, index: u8) {
            self.fbb_
                .push_slot::<u8>(InnerInstructions::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_instructions(
            &mut self,
            instructions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CompiledInstruction<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                InnerInstructions::VT_INSTRUCTIONS,
                instructions,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> InnerInstructionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InnerInstructionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InnerInstructions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InnerInstructions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InnerInstructions");
            ds.field("index", &self.index());
            ds.field("instructions", &self.instructions());
            ds.finish()
        }
    }
    pub enum TransactionTokenBalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionTokenBalance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionTokenBalance<'a> {
        type Inner = TransactionTokenBalance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionTokenBalance<'a> {
        pub const VT_ACCOUNT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_MINT: flatbuffers::VOffsetT = 6;
        pub const VT_UI_TOKEN_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_OWNER: flatbuffers::VOffsetT = 10;
        pub const VT_PROGRAM_ID: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionTokenBalance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransactionTokenBalanceArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionTokenBalance<'bldr>> {
            let mut builder = TransactionTokenBalanceBuilder::new(_fbb);
            if let Some(x) = args.program_id {
                builder.add_program_id(x);
            }
            if let Some(x) = args.owner {
                builder.add_owner(x);
            }
            if let Some(x) = args.ui_token_amount {
                builder.add_ui_token_amount(x);
            }
            if let Some(x) = args.mint {
                builder.add_mint(x);
            }
            builder.add_account_index(args.account_index);
            builder.finish()
        }

        #[inline]
        pub fn account_index(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(TransactionTokenBalance::VT_ACCOUNT_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn mint(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionTokenBalance::VT_MINT,
                    None,
                )
            }
        }
        #[inline]
        pub fn ui_token_amount(&self) -> Option<UiTokenAmount<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<UiTokenAmount>>(
                        TransactionTokenBalance::VT_UI_TOKEN_AMOUNT,
                        None,
                    )
            }
        }
        #[inline]
        pub fn owner(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionTokenBalance::VT_OWNER,
                    None,
                )
            }
        }
        #[inline]
        pub fn program_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionTokenBalance::VT_PROGRAM_ID,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionTokenBalance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("account_index", Self::VT_ACCOUNT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint", Self::VT_MINT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UiTokenAmount>>(
                    "ui_token_amount",
                    Self::VT_UI_TOKEN_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("owner", Self::VT_OWNER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "program_id",
                    Self::VT_PROGRAM_ID,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionTokenBalanceArgs<'a> {
        pub account_index: u8,
        pub mint: Option<flatbuffers::WIPOffset<&'a str>>,
        pub ui_token_amount: Option<flatbuffers::WIPOffset<UiTokenAmount<'a>>>,
        pub owner: Option<flatbuffers::WIPOffset<&'a str>>,
        pub program_id: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransactionTokenBalanceArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionTokenBalanceArgs {
                account_index: 0,
                mint: None,
                ui_token_amount: None,
                owner: None,
                program_id: None,
            }
        }
    }

    pub struct TransactionTokenBalanceBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransactionTokenBalanceBuilder<'a, 'b> {
        #[inline]
        pub fn add_account_index(&mut self, account_index: u8) {
            self.fbb_
                .push_slot::<u8>(TransactionTokenBalance::VT_ACCOUNT_INDEX, account_index, 0);
        }
        #[inline]
        pub fn add_mint(&mut self, mint: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionTokenBalance::VT_MINT,
                mint,
            );
        }
        #[inline]
        pub fn add_ui_token_amount(
            &mut self,
            ui_token_amount: flatbuffers::WIPOffset<UiTokenAmount<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<UiTokenAmount>>(
                    TransactionTokenBalance::VT_UI_TOKEN_AMOUNT,
                    ui_token_amount,
                );
        }
        #[inline]
        pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionTokenBalance::VT_OWNER,
                owner,
            );
        }
        #[inline]
        pub fn add_program_id(&mut self, program_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionTokenBalance::VT_PROGRAM_ID,
                program_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransactionTokenBalanceBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransactionTokenBalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionTokenBalance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionTokenBalance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionTokenBalance");
            ds.field("account_index", &self.account_index());
            ds.field("mint", &self.mint());
            ds.field("ui_token_amount", &self.ui_token_amount());
            ds.field("owner", &self.owner());
            ds.field("program_id", &self.program_id());
            ds.finish()
        }
    }
    pub enum UiTokenAmountOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UiTokenAmount<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UiTokenAmount<'a> {
        type Inner = UiTokenAmount<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UiTokenAmount<'a> {
        pub const VT_UI_AMOUNT: flatbuffers::VOffsetT = 4;
        pub const VT_DECIMALS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_UI_AMOUNT_STRING: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UiTokenAmount { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UiTokenAmountArgs<'args>,
        ) -> flatbuffers::WIPOffset<UiTokenAmount<'bldr>> {
            let mut builder = UiTokenAmountBuilder::new(_fbb);
            builder.add_ui_amount(args.ui_amount);
            if let Some(x) = args.ui_amount_string {
                builder.add_ui_amount_string(x);
            }
            if let Some(x) = args.amount {
                builder.add_amount(x);
            }
            builder.add_decimals(args.decimals);
            builder.finish()
        }

        #[inline]
        pub fn ui_amount(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(UiTokenAmount::VT_UI_AMOUNT, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn decimals(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(UiTokenAmount::VT_DECIMALS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn amount(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UiTokenAmount::VT_AMOUNT, None)
            }
        }
        #[inline]
        pub fn ui_amount_string(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    UiTokenAmount::VT_UI_AMOUNT_STRING,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for UiTokenAmount<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f64>("ui_amount", Self::VT_UI_AMOUNT, false)?
                .visit_field::<u8>("decimals", Self::VT_DECIMALS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "amount",
                    Self::VT_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "ui_amount_string",
                    Self::VT_UI_AMOUNT_STRING,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UiTokenAmountArgs<'a> {
        pub ui_amount: f64,
        pub decimals: u8,
        pub amount: Option<flatbuffers::WIPOffset<&'a str>>,
        pub ui_amount_string: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UiTokenAmountArgs<'a> {
        #[inline]
        fn default() -> Self {
            UiTokenAmountArgs {
                ui_amount: 0.0,
                decimals: 0,
                amount: None,
                ui_amount_string: None,
            }
        }
    }

    pub struct UiTokenAmountBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UiTokenAmountBuilder<'a, 'b> {
        #[inline]
        pub fn add_ui_amount(&mut self, ui_amount: f64) {
            self.fbb_
                .push_slot::<f64>(UiTokenAmount::VT_UI_AMOUNT, ui_amount, 0.0);
        }
        #[inline]
        pub fn add_decimals(&mut self, decimals: u8) {
            self.fbb_
                .push_slot::<u8>(UiTokenAmount::VT_DECIMALS, decimals, 0);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UiTokenAmount::VT_AMOUNT, amount);
        }
        #[inline]
        pub fn add_ui_amount_string(&mut self, ui_amount_string: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UiTokenAmount::VT_UI_AMOUNT_STRING,
                ui_amount_string,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UiTokenAmountBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UiTokenAmountBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UiTokenAmount<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UiTokenAmount<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UiTokenAmount");
            ds.field("ui_amount", &self.ui_amount());
            ds.field("decimals", &self.decimals());
            ds.field("amount", &self.amount());
            ds.field("ui_amount_string", &self.ui_amount_string());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `TransactionInfo`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_info_unchecked`.
    pub fn root_as_transaction_info(
        buf: &[u8],
    ) -> Result<TransactionInfo, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<TransactionInfo>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `TransactionInfo` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_transaction_info_unchecked`.
    pub fn size_prefixed_root_as_transaction_info(
        buf: &[u8],
    ) -> Result<TransactionInfo, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<TransactionInfo>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `TransactionInfo` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_info_unchecked`.
    pub fn root_as_transaction_info_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<TransactionInfo<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<TransactionInfo<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `TransactionInfo` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_info_unchecked`.
    pub fn size_prefixed_root_as_transaction_info_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<TransactionInfo<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<TransactionInfo<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a TransactionInfo and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `TransactionInfo`.
    pub unsafe fn root_as_transaction_info_unchecked(buf: &[u8]) -> TransactionInfo {
        flatbuffers::root_unchecked::<TransactionInfo>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed TransactionInfo and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `TransactionInfo`.
    pub unsafe fn size_prefixed_root_as_transaction_info_unchecked(buf: &[u8]) -> TransactionInfo {
        flatbuffers::size_prefixed_root_unchecked::<TransactionInfo>(buf)
    }
    #[inline]
    pub fn finish_transaction_info_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<TransactionInfo<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_transaction_info_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<TransactionInfo<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod TransactionInfo
